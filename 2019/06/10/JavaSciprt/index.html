<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.8.0">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="1.同源策略同源策略可防止 JavaScript 发起跨域请求。源被定义为 URI、主机名和端口号的组合。此策略可防止页面上的恶意脚本通过该页面的文档对象模型，访问另一个网页上的敏感数据。
2.跨域
原因 浏览器的同源策略导致了跨域
作用 用于隔离潜在恶意文件的重要安全机制
解决


jsonp ，">
    

    <!--Author-->
    
        <meta name="author" content="John Doe">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Hexo">
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Hexo">

    <!--Type page-->
    
        <meta property="og:type" content="website">
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary">
    

    <!-- Title -->
    
    <title>Hexo</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
    </div>
</header>

        <section class="main">
            
<div class="post">

    <div class="post-header">
        <h1 class="title">
            <a href="/2019/06/10/JavaSciprt/">
                Untitled
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-06-10</span>
            
            
            
        </div>
    </div>

    <div class="content">

        <!-- Gallery -->
        

        <!-- Post Content -->
        <h4 id="1-同源策略"><a href="#1-同源策略" class="headerlink" title="1.同源策略"></a>1.同源策略</h4><p>同源策略可防止 JavaScript 发起跨域请求。源被定义为 URI、主机名和端口号的组合。此策略可防止页面上的恶意脚本通过该页面的文档对象模型，访问另一个网页上的敏感数据。</p>
<h4 id="2-跨域"><a href="#2-跨域" class="headerlink" title="2.跨域"></a>2.跨域</h4><ul>
<li>原因 <br><br>浏览器的同源策略导致了跨域</li>
<li>作用 <br><br>用于隔离潜在恶意文件的重要安全机制</li>
<li>解决</li>
</ul>
<ol>
<li>jsonp ，允许 script 加载第三方资源</li>
<li>反向代理（nginx 服务内部配置 Access-Control-Allow-Origin ）</li>
<li>cors 前后端协作设置请求头部，Access-Control-Allow-Origin 等头部信息</li>
<li>iframe 嵌套通讯，postmessage</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/41479807" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41479807</a> <br><br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 阮一峰</a></p>
<h4 id="3-JSONP"><a href="#3-JSONP" class="headerlink" title="3.JSONP"></a>3.JSONP</h4><p>Jsonp 并不是一种数据格式，而 json 是一种数据格式，jsonp 是用来解决跨域获取数据的一种解决方案，具体是通过动态创建 script 标签，然后通过标签的 src 属性获取 js 文件中的 js 脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是 ajax 技术</p>
<p>这是我认为写得比较通俗易懂的一篇文章 直接转载过来<br><br><a href="https://blog.csdn.net/hansexploration/article/details/80314948" target="_blank" rel="noopener">https://blog.csdn.net/hansexploration/article/details/80314948</a></p>
<h4 id="4-事件绑定的方式"><a href="#4-事件绑定的方式" class="headerlink" title="4.事件绑定的方式"></a>4.事件绑定的方式</h4><ul>
<li><p>嵌入dom</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;func()&quot;&gt;按钮&lt;/button&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = function()&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(&apos;click&apos;,function()&#123;&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-事件委托"><a href="#5-事件委托" class="headerlink" title="5.事件委托"></a>5.事件委托</h4><p>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术，<br>使用事件委托可以节省内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;苹果&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;香蕉&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;凤梨&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">document.querySelector(&apos;ul&apos;).onclick = (event) =&gt; &#123;</span><br><span class="line">  let target = event.target</span><br><span class="line">  if (target.nodeName === &apos;LI&apos;) &#123;</span><br><span class="line">    console.log(target.innerHTML)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">document.querySelectorAll(&apos;li&apos;).forEach((e) =&gt; &#123;</span><br><span class="line">  e.onclick = function() &#123;</span><br><span class="line">    console.log(this.innerHTML)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="6-事件循环"><a href="#6-事件循环" class="headerlink" title="6.事件循环"></a>6.事件循环</h4><p>事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行。</p>
<h4 id="7-事件模型"><a href="#7-事件模型" class="headerlink" title="7.事件模型"></a>7.事件模型</h4><ul>
<li><p>DOM0<br><br>直接绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input onclick=&quot;sayHi()&quot;/&gt;</span><br><span class="line"></span><br><span class="line">btn.onclick = function() &#123;&#125;</span><br><span class="line">btn.onclick = null</span><br></pre></td></tr></table></figure>
</li>
<li><p>DOM2<br><br>DOM2级事件可以冒泡和捕获<br>通过addEventListener绑定<br>通过removeEventListener解绑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 绑定</span><br><span class="line">btn.addEventListener(&apos;click&apos;, sayHi)</span><br><span class="line">// 解绑</span><br><span class="line">btn.removeEventListener(&apos;click&apos;, sayHi)</span><br></pre></td></tr></table></figure>
</li>
<li><p>DOM3<br><br>DOM3具有更多事件类型<br>DOM3级事件在DOM2级事件的基础上添加了更多的事件类型，全部类型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UI事件，当用户与页面上的元素交互时触发，如：load、scroll</span><br><span class="line">焦点事件，当元素获得或失去焦点时触发，如：blur、focus</span><br><span class="line">鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup</span><br><span class="line">滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</span><br><span class="line">文本事件，当在文档中输入文本时触发，如：textInput</span><br><span class="line">键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</span><br><span class="line">合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart</span><br><span class="line">变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><a href="https://www.jianshu.com/p/3acdf5f71d5b" target="_blank" rel="noopener">https://www.jianshu.com/p/3acdf5f71d5b</a></p>
<h4 id="8-target和currentTarget区别"><a href="#8-target和currentTarget区别" class="headerlink" title="8.target和currentTarget区别"></a>8.target和currentTarget区别</h4><ul>
<li>event.target<br><br>返回触发事件的元素</li>
<li>event.currentTarget<br><br>返回绑定事件的元素</li>
</ul>
<h4 id="9-prototype和proto的关系是什么"><a href="#9-prototype和proto的关系是什么" class="headerlink" title="9.prototype和proto的关系是什么"></a>9.prototype和<strong>proto</strong>的关系是什么</h4><p>所有的对象都拥有<strong>proto</strong>属性，它指向Object.prototype（Object是一个原生函数，所有的对象都是Object的实例）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;</span><br><span class="line">obj.__proto__ === Object.prototype // true</span><br></pre></td></tr></table></figure>

<p>所有的函数都同时拥有<strong>proto</strong>和protytpe属性<br>函数的<strong>proto</strong>指向自己的函数实现 函数的protytpe是一个对象 所以函数的prototype也有<strong>proto</strong>属性 指向Object.prototype</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function func() &#123;&#125;</span><br><span class="line">func.prototype.__proto__ === Object.prototype // true</span><br></pre></td></tr></table></figure>

<p>Object.prototype.<strong>proto</strong>指向null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.__proto__ // null</span><br></pre></td></tr></table></figure>

<h4 id="10-什么是Ajax-ajax常用属性和方法"><a href="#10-什么是Ajax-ajax常用属性和方法" class="headerlink" title="10.什么是Ajax,ajax常用属性和方法"></a>10.什么是Ajax,ajax常用属性和方法</h4><p>Ajax(asynchronous JavaScript and XML)是使用客户端上的许多 Web 技术，创建异步 Web 应用的一种 Web 开发技术。借助 Ajax，Web 应用可以异步（在后台）向服务器发送数据和从服务器检索数据，而不会干扰现有页面的显示和行为。通过将数据交换层与表示层分离，Ajax 允许网页和扩展 Web 应用程序动态更改内容，而无需重新加载整个页面。实际上，现在通常将 JSON 替换为 XML，因为 JavaScript 对 JSON 有原生支持优势。<br><br>XMLHttpRequest API 经常用于异步通信。此外还有最近流行的fetch API。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let xmlhttp</span><br><span class="line">if (window.XMLHttpRequest) &#123;</span><br><span class="line">	//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span><br><span class="line">	xmlhttp = new XMLHttpRequest()</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	// IE6, IE5 浏览器执行代码</span><br><span class="line">	xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.onreadystatechange = () =&gt; &#123;</span><br><span class="line">	if (xmlhttp.readyState === 4 &amp;&amp; xmlhttp.status === 200) &#123;</span><br><span class="line">		document.getElementById(&quot;myDiv&quot;).innerHTML = xmlhttp.responseText</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.open(&quot;GET&quot;, &quot;/ajax/test.txt&quot;, true)</span><br><span class="line">xmlhttp.send()</span><br></pre></td></tr></table></figure>

<h4 id="11-Ajax和Fetch区别"><a href="#11-Ajax和Fetch区别" class="headerlink" title="11.Ajax和Fetch区别"></a>11.Ajax和Fetch区别</h4><ul>
<li>ajax是使用XMLHttpRequest对象发起的，但是用起来很麻烦，所以ES6新规范就有了fetch，fetch发一个请求不用像ajax那样写一大堆代码。</li>
<li>使用fetch无法取消一个请求，这是因为fetch基于Promise，而Promise无法做到这一点。</li>
<li>在默认情况下，fetch不会接受或者发送cookies</li>
<li>fetch没有办法原生监测请求的进度，而XMLHttpRequest可以</li>
<li>fetch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理</li>
<li>fetch由于是ES6规范，兼容性上比不上XMLHttpRequest</li>
</ul>
<h4 id="12-ajax-的缺点"><a href="#12-ajax-的缺点" class="headerlink" title="12.ajax 的缺点"></a>12.ajax 的缺点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、ajax 不支持浏览器 back 按钮。</span><br><span class="line">2、安全问题 AJAX 暴露了与服务器交互的细节。</span><br><span class="line">3、对搜索引擎的支持比较弱。</span><br><span class="line">4、破坏了程序的异常机制。</span><br><span class="line">5、ajax跨域访问的问题</span><br></pre></td></tr></table></figure>

<h4 id="13-变量提升"><a href="#13-变量提升" class="headerlink" title="13.变量提升"></a>13.变量提升</h4><p>var会使变量提升，这意味着变量可以在声明之前使用。let和const不会使变量提升，提前使用会报错。<br>变量提升（hoisting）是用于解释代码中变量声明行为的术语。使用var关键字声明或初始化的变量，会将声明语句“提升”到当前作用域的顶部。 但是，只有声明才会触发提升，赋值语句（如果有的话）将保持原样。函数提升在变量提升之前</p>
<h4 id="13-当你在浏览器输入一个地址后发生了什么"><a href="#13-当你在浏览器输入一个地址后发生了什么" class="headerlink" title="13.当你在浏览器输入一个地址后发生了什么"></a>13.当你在浏览器输入一个地址后发生了什么</h4><p>参照php课件图</p>
<h4 id="14-cookie、localStorage、sessionStorage区别"><a href="#14-cookie、localStorage、sessionStorage区别" class="headerlink" title="14.cookie、localStorage、sessionStorage区别"></a>14.cookie、localStorage、sessionStorage区别</h4><table>
<thead>
<tr>
<th>特性</th>
<th>cookie</th>
<th>localStorage</th>
<th>sessionStorage</th>
</tr>
</thead>
<tbody><tr>
<td>数据的生命周期</td>
<td>一般由服务器生成，可设置失效时间，如果在浏览器生成，默认是关闭浏览器之后失效</td>
<td>永久保存，可清除</td>
<td>仅在当前会话有效，关闭页面后清除</td>
</tr>
<tr>
<td>存放数据大小</td>
<td>4KB</td>
<td>5MB</td>
<td>5MB</td>
</tr>
<tr>
<td>与服务器通信</td>
<td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>
<td>仅在客户端保存</td>
<td>仅在客户端保存</td>
</tr>
<tr>
<td>用途</td>
<td>一般由服务器生成，用于标识用户身份</td>
<td>用于浏览器缓存数据</td>
<td>用于浏览器缓存数据</td>
</tr>
</tbody></table>
<h4 id="15-自执行函数-用于什么场景？好处"><a href="#15-自执行函数-用于什么场景？好处" class="headerlink" title="15.自执行函数?用于什么场景？好处?"></a>15.自执行函数?用于什么场景？好处?</h4><p>自执行函数:1、声明一个匿名函数2、马上调用这个匿名函数。<br><br>作用：创建一个独立的作用域。<br></p>
<p>好处：防止变量弥散到全局，以免各种js库冲突。隔离作用域避免污染，或者截断作用域链，避免闭包造成引用变量无法释放。利用立即执行特性，返回需要的业务函数或对象，避免每次通过条件判断来处理<br></p>
<p>场景：一般用于框架、插件等场景</p>
<h4 id="16-实现add函数-让add-a-b-和add-a-b-两种调用结果相同"><a href="#16-实现add函数-让add-a-b-和add-a-b-两种调用结果相同" class="headerlink" title="16.实现add函数,让add(a)(b)和add(a,b)两种调用结果相同"></a>16.实现add函数,让add(a)(b)和add(a,b)两种调用结果相同</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">    if (b === undefined) &#123;</span><br><span class="line">        return function(x) &#123;</span><br><span class="line">            return a + x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id><a href="#" class="headerlink" title></a><a href="#JavaScript"></a></h4><h4 id="17-js中万物皆对象你认为对么"><a href="#17-js中万物皆对象你认为对么" class="headerlink" title="17.js中万物皆对象你认为对么"></a>17.js中万物皆对象你认为对么</h4><p>我认为是对的<br>在JS中有原生函数、基本数据类型，它们的原型最终还是对象。<br>可以看看本文的原生函数</p>
<h4 id="-1"><a href="#-1" class="headerlink" title></a><a href="#JavaScript"></a></h4><h4 id="18-多个页面之间如何进行通信"><a href="#18-多个页面之间如何进行通信" class="headerlink" title="18.多个页面之间如何进行通信"></a>18.多个页面之间如何进行通信</h4><p>有如下几个方式：</p>
<ul>
<li>cookie</li>
<li>web worker</li>
<li>localeStorage和sessionStorage</li>
</ul>
<h4 id="19-css动画和js动画的差异"><a href="#19-css动画和js动画的差异" class="headerlink" title="19.css动画和js动画的差异"></a>19.css动画和js动画的差异</h4><ol>
<li>代码复杂度，js 动画代码相对复杂一些</li>
<li>动画运行时，对动画的控制程度上，js 能够让动画，暂停，取消，终止，css动画不能添加事件</li>
<li>动画性能看，js 动画多了一个js 解析的过程，性能不如 css 动画好</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/41479807" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41479807</a></p>
<h4 id="-2"><a href="#-2" class="headerlink" title></a><a href="#JavaScript"></a></h4><h4 id="20-请用js去除字符串空格"><a href="#20-请用js去除字符串空格" class="headerlink" title="20.请用js去除字符串空格"></a>20.请用js去除字符串空格</h4><p>去除所有空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.replace(/\s/g, &apos;&apos;)</span><br></pre></td></tr></table></figure>

<p>去除两边空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str.replace(/^\s+|\s+$/g, &apos;&apos;)</span><br><span class="line">// 原生方法</span><br><span class="line">str.trim()</span><br></pre></td></tr></table></figure>

<h4 id="21-清除浮动的几种方式"><a href="#21-清除浮动的几种方式" class="headerlink" title="21.清除浮动的几种方式"></a>21.清除浮动的几种方式</h4><ul>
<li>对父级设置适合CSS高度</li>
<li>父级div定义 overflow:hidden</li>
<li>clear:both清除浮动</li>
<li>微元素清楚浮动</li>
</ul>
<h4 id="22-new一个对象经历了什么"><a href="#22-new一个对象经历了什么" class="headerlink" title="22.new一个对象经历了什么"></a>22.new一个对象经历了什么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Test()&#123;&#125;</span><br><span class="line">const test = new Test()</span><br></pre></td></tr></table></figure>

<ol>
<li><p>创建一个新对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置新对象的constructor属性为构造函数的名称，设置新对象的<strong>proto</strong>属性指向构造函数的prototype对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.constructor = Test</span><br><span class="line">obj.__proto__ = Test.prototype</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用新对象调用函数，函数中的this被指向新实例对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test.call(obj)</span><br></pre></td></tr></table></figure>
</li>
<li><p>将初始化完毕的新对象地址，保存到等号左边的变量中</p>
</li>
</ol>
<h4 id="23-如何实现文件断点续传"><a href="#23-如何实现文件断点续传" class="headerlink" title="23.如何实现文件断点续传"></a>23.如何实现文件断点续传</h4><p>断点续传最核心的内容就是把文件“切片”然后再一片一片的传给服务器，但是这看似简单的上传过程却有着无数的坑。</p>
<p>首先是文件的识别，一个文件被分成了若干份之后如何告诉服务器你切了多少块，以及最终服务器应该如何把你上传上去的文件进行合并，这都是要考虑的。</p>
<p>因此在文件开始上传之前，我们和服务器要有一个“握手”的过程，告诉服务器文件信息，然后和服务器约定切片的大小，当和服务器达成共识之后就可以开始后续的文件传输了。</p>
<p>前台要把每一块的文件传给后台，成功之后前端和后端都要标识一下，以便后续的断点。</p>
<p>当文件传输中断之后用户再次选择文件就可以通过标识来判断文件是否已经上传了一部分，如果是的话，那么我们可以接着上次的进度继续传文件，以达到续传的功能。<br>有了HTML5 的 File api之后切割文件比想想的要简单的多的多。</p>
<p>只要用slice 方法就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var packet = file.slice(start, end);</span><br></pre></td></tr></table></figure>

<p>参数start是开始切片的位置，end是切片结束的位置 单位都是字节。通过控制start和end 就可以是实现文件的分块</p>
<p>如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file.slice(0,1000);</span><br><span class="line">file.slice(1000,2000);</span><br><span class="line">file.slice(2000,3000);</span><br><span class="line">// ......</span><br></pre></td></tr></table></figure>

<p>在把文件切成片之后，接下来要做的事情就是把这些碎片传到服务器上。<br>如果中间掉线了，下次再传的时候就得先从服务器获取上一次上传文件的位置，然后以这个位置开始上传接下来的文件内容。</p>
<p><a href="https://www.cnblogs.com/zhwl/p/3580776.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhwl/p/3580776.html</a></p>
<h4 id="24-bind、call、apply的区别"><a href="#24-bind、call、apply的区别" class="headerlink" title="24.bind、call、apply的区别"></a>24.bind、call、apply的区别</h4><p>call和apply其实是一样的，区别就在于传参时参数是一个一个传或者是以一个数组的方式来传。<br><br>call和apply都是在调用时生效，改变调用者的this指向。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let name = &apos;Jack&apos;</span><br><span class="line">const obj = &#123;name: &apos;Tom&apos;&#125;</span><br><span class="line">function sayHi() &#123;console.log(&apos;Hi! &apos; + this.name)&#125;</span><br><span class="line"></span><br><span class="line">sayHi() // Hi! Jack</span><br><span class="line">sayHi.call(obj) // Hi! Tom</span><br></pre></td></tr></table></figure>

<p>bind也是改变this指向，不过不是在调用时生效，而是返回一个新函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const newFunc = sayHi.bind(obj)</span><br><span class="line">newFunc() // Hi! Tom</span><br></pre></td></tr></table></figure>

<h4 id="25-JS的数据类型有哪些？typeof运算符的执行结果都有哪些数据类型？"><a href="#25-JS的数据类型有哪些？typeof运算符的执行结果都有哪些数据类型？" class="headerlink" title="25.JS的数据类型有哪些？typeof运算符的执行结果都有哪些数据类型？"></a>25.JS的数据类型有哪些？typeof运算符的执行结果都有哪些数据类型？</h4><p>数据类型主要包括两部分：</p>
<p>基本数据类型： Undefined、Null、Boolean、Number和String</p>
<p>引用数据类型： Array 、Object</p>
<p>typeof运算符的结果类型：</p>
<p>number,string，boolean,object,function,undefined</p>
<h4 id="26-null，undefined-的区别"><a href="#26-null，undefined-的区别" class="headerlink" title="26.null，undefined 的区别?"></a>26.null，undefined 的区别?</h4><p>null        表示一个对象被定义了，值为“空值”；</p>
<p>undefined   表示不存在这个值。</p>
<h4 id="27-怎么判断一个变量没有被定义"><a href="#27-怎么判断一个变量没有被定义" class="headerlink" title="27.怎么判断一个变量没有被定义"></a>27.怎么判断一个变量没有被定义</h4><p>typeof bianliang ==”undefined”</p>
<h4 id="28-怎么判断一个变量arr的话是否为数组（此题用typeof不行）"><a href="#28-怎么判断一个变量arr的话是否为数组（此题用typeof不行）" class="headerlink" title="28.怎么判断一个变量arr的话是否为数组（此题用typeof不行）"></a>28.怎么判断一个变量arr的话是否为数组（此题用typeof不行）</h4><p>Arr instanceof Array</p>
<h4 id="29-描述下JSON对象的两个很重要的方法"><a href="#29-描述下JSON对象的两个很重要的方法" class="headerlink" title="29.描述下JSON对象的两个很重要的方法"></a>29.描述下JSON对象的两个很重要的方法</h4><p>JSON.parse() //JSON字符串转换为JSON对象</p>
<p>JSON.stringify() //JSON对象转化为字符串</p>
<h4 id="30-“-”、“-”的区别？"><a href="#30-“-”、“-”的区别？" class="headerlink" title="30.“ ===”、“ ==”的区别？"></a>30.“ ===”、“ ==”的区别？</h4><p>==，当且仅当两个运算数相等时，它返回 true，即不检查数据类型</p>
<p>===，只有在无需类型转换运算数就相等的情况下，才返回 true，需要检查数据类型</p>
<h4 id="31-原型、原型链？"><a href="#31-原型、原型链？" class="headerlink" title="31.原型、原型链？"></a>31.原型、原型链？</h4><p>每个由构造函数new出来的实例化对象都自带一个_proto_属性，该属性指向创建它的构造函数的prototype对象。而prototype对象因为是实例，也有自己的_proto_属性，指向它的原型对象。当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，</p>
<p>于是就这样一直找下去，也就是我们平时所说的原型链的概念。</p>
<p>关系：instance.constructor.prototype= instance.<strong>proto</strong></p>
<h4 id="32-eval是做什么的？"><a href="#32-eval是做什么的？" class="headerlink" title="32.eval是做什么的？"></a>32.eval是做什么的？</h4><p>它的功能是把对应的字符串解析成JS代码并运行；</p>
<p>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。</p>
<p>由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’);</p>
<h4 id="33-简单jQuery：请写出代码，ul标签下面有1000个li，写一个性能最高的方式实现，在点击li后，输出li的内容"><a href="#33-简单jQuery：请写出代码，ul标签下面有1000个li，写一个性能最高的方式实现，在点击li后，输出li的内容" class="headerlink" title="33.简单jQuery：请写出代码，ul标签下面有1000个li，写一个性能最高的方式实现，在点击li后，输出li的内容"></a>33.简单jQuery：请写出代码，ul标签下面有1000个li，写一个性能最高的方式实现，在点击li后，输出li的内容</h4><p>$(“ul”).on(“click”,”li”,function(){</p>
<p>$(this).html(“hit”);</p>
<p>})</p>
<h4 id="34-简述下为何通过ajax发送的请求会出现乱码问题，如何解决？"><a href="#34-简述下为何通过ajax发送的请求会出现乱码问题，如何解决？" class="headerlink" title="34.简述下为何通过ajax发送的请求会出现乱码问题，如何解决？"></a>34.简述下为何通过ajax发送的请求会出现乱码问题，如何解决？</h4><p>乱码的问题就是编码格式冲突，我们需要传输中文数据前面加一个encodeURI()编码，例如：encodeURI(j$(“#fk_info”).val())；在接受参数的页面对传过来的编码过后的内容用后端语言进行解码</p>
<h4 id="35-简述DOM，HTML-DOM的区别和联系"><a href="#35-简述DOM，HTML-DOM的区别和联系" class="headerlink" title="35.简述DOM，HTML DOM的区别和联系"></a>35.简述DOM，HTML DOM的区别和联系</h4><p>DOM分为三部分：</p>
<p>（1）核心DOM：遍历DOM树、添加新节点、删除节点、修改节点</p>
<p>（2）HTML DOM：以一种简便的方法访问DOM树</p>
<p>（3）XML DOM：准用于操作XML文档</p>
<p>核心DOM与HTML DOM的区别：</p>
<p>核心DOM ：</p>
<p>对象：Document,Node,  ElementNode,TextNode,AttributeNode，CommentNode,NodeList</p>
<p>核心DOM提供了统一的操作接口，如：createElement、appendChild、setAttribute等</p>
<p>核心DOM创建新元素：var newNode=document.createElement(“img”)</p>
<p>给元素添加属性：e.setAttribure()、e.setAttribureNode()</p>
<p>适用场合：核心DOM适合操作节点，如创建，删除，查找等</p>
<p>HTML DOM：</p>
<p>对象：image,Table,Form,Input,Select等等HTML标签对象化</p>
<p>HTML DOM提供了封装好的各种对象，如：Select、Option等等</p>
<p>适用场合：HTML DOM适合操作属性，如读取或修改属性的值</p>
<h4 id="36-什么是事件流"><a href="#36-什么是事件流" class="headerlink" title="36.什么是事件流"></a>36.什么是事件流</h4><p>DOM(文档对象模型)结构是一个树型结构，当一个HTML元素产生一个事件时，该事件会在元素结点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。DOM同时支持两种事件模型：捕获型事件和冒泡型事件</p>
<h4 id="37-JavaScript原型继承是如何运作的？"><a href="#37-JavaScript原型继承是如何运作的？" class="headerlink" title="37.JavaScript原型继承是如何运作的？"></a>37.JavaScript原型继承是如何运作的？</h4><p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去(知道找到null为止)，也就是我们平时所说的原型链的概念。</p>
<h4 id="38-DOM元素Attribute与Property的区别是什么？"><a href="#38-DOM元素Attribute与Property的区别是什么？" class="headerlink" title="38.DOM元素Attribute与Property的区别是什么？"></a>38.DOM元素Attribute与Property的区别是什么？</h4><p>1、 property是DOM中的属性，是JavaScript里的对象；而attribute是HTML标签上的特性，它的值只能够是字符串；</p>
<p>2、DOM对象初始化时会在创建默认的基本property；只有在HTML标签中定义的attribute才会被保存在property的attributes属性中；</p>
<p>3、attribute会初始化property中的同名属性，但自定义的attribute不会出现在property中；</p>
<p>4、propety是对象，而attribute的值都是字符串；</p>
<p>5、最关键的两句话：</p>
<p>attribute（特性），是我们赋予某个事物的特质或对象。</p>
<p>property（属性），是早已存在的不需要外界赋予的特质。</p>
<h4 id="39-Long-Polling、WebSocket、SSE-Server-Sent-Events-之间有什么差异？请写出WebSocket在浏览器端如何发送及接收消息的相关代码实现（需要考虑传输一场并根据返回数据的格式做不同处理）"><a href="#39-Long-Polling、WebSocket、SSE-Server-Sent-Events-之间有什么差异？请写出WebSocket在浏览器端如何发送及接收消息的相关代码实现（需要考虑传输一场并根据返回数据的格式做不同处理）" class="headerlink" title="39.Long-Polling、WebSocket、SSE(Server-Sent Events)之间有什么差异？请写出WebSocket在浏览器端如何发送及接收消息的相关代码实现（需要考虑传输一场并根据返回数据的格式做不同处理）"></a>39.Long-Polling、WebSocket、SSE(Server-Sent Events)之间有什么差异？请写出WebSocket在浏览器端如何发送及接收消息的相关代码实现（需要考虑传输一场并根据返回数据的格式做不同处理）</h4><p>Long-Polling 自己主动请求数据来获知文件知否发生变化  缺点：会有很多无效请求</p>
<p>SSE 服务器端通知客户端数据变化 服务器端客户端保持一个长连接 缺点：保持长连接需要占用大量的服务器端只要</p>
<p>WebSocket 实时通信 缺点：浏览器支持情况没有上面两种方法好 </p>
<h4 id="40-指出下面代码的区别"><a href="#40-指出下面代码的区别" class="headerlink" title="40.指出下面代码的区别"></a>40.指出下面代码的区别</h4><p>function Order(){</p>
<p>}</p>
<p>var order = Order();  （1）</p>
<p>var order = new Order();（2）</p>
<p>代码（1）是将函数Order()作为一个普通函数去调用的，代码（2）是将Order()作为一个构造函数去调用的；当函数Order的方法体中有this关键之的时候，作为普通函数this指的是window对象，作为构造函数存在的时候this指代的是本对象</p>
<h4 id="41-document-ready-是个什么函数？为什么要用它。"><a href="#41-document-ready-是个什么函数？为什么要用它。" class="headerlink" title="41.$(document).ready()是个什么函数？为什么要用它。"></a>41.$(document).ready()是个什么函数？为什么要用它。</h4><p>问题一： $(document).ready()这个函数是用来取代页面中的window.onload; 不同的是onload()的方法是在页面加载完成后才发生，这包括DOM元素和其他页面元素（例如图片）的加载，因此，使用document.ready()方法的执行速度比onload()的方法要快。</p>
<p>问题二：Javascript 只有在DOM元素已经定义以后才可以对其执行某种操作，jQuery使用document.ready来保证所要执行的代码是在DOM元素被加载完成的情况下执行。 </p>
<h4 id="43-请写一个正则，匹配输入的字符：第一个必须是字母或下划线开头，后面就是字母和数字或下划线构成，长度5-20"><a href="#43-请写一个正则，匹配输入的字符：第一个必须是字母或下划线开头，后面就是字母和数字或下划线构成，长度5-20" class="headerlink" title="43.请写一个正则，匹配输入的字符：第一个必须是字母或下划线开头，后面就是字母和数字或下划线构成，长度5-20."></a>43.请写一个正则，匹配输入的字符：第一个必须是字母或下划线开头，后面就是字母和数字或下划线构成，长度5-20.</h4><p>答案： /^[A-Za-z_]\w{4,19}$/</p>
<h4 id="44-JS中原型链最上层的对象是-object-的原型对象，该对象的-proto-指针指向-null-的原型对象。"><a href="#44-JS中原型链最上层的对象是-object-的原型对象，该对象的-proto-指针指向-null-的原型对象。" class="headerlink" title="44.JS中原型链最上层的对象是  object  的原型对象，该对象的_proto_指针指向  null    的原型对象。"></a>44.JS中原型链最上层的对象是  object  的原型对象，该对象的_proto_指针指向  null    的原型对象。</h4><h4 id="45-JS中使用-Object-对象的-defineProperty-函数定义对象属性的访问器。"><a href="#45-JS中使用-Object-对象的-defineProperty-函数定义对象属性的访问器。" class="headerlink" title="45.JS中使用 Object 对象的   defineProperty    函数定义对象属性的访问器。"></a>45.JS中使用 Object 对象的   defineProperty    函数定义对象属性的访问器。</h4><h4 id="46-如何对一篇文章进行敏感词替换？假如有几千个敏感词。（写一下思路即可）"><a href="#46-如何对一篇文章进行敏感词替换？假如有几千个敏感词。（写一下思路即可）" class="headerlink" title="46.如何对一篇文章进行敏感词替换？假如有几千个敏感词。（写一下思路即可）"></a>46.如何对一篇文章进行敏感词替换？假如有几千个敏感词。（写一下思路即可）</h4><p>将这篇文章以字符串的形式赋给一个变量。定义一个正则表达式，以全局匹配的方式查找所有敏感词，并用replace方法替换掉</p>
<h4 id="47-添加、删除、更改、插入节点的方法"><a href="#47-添加、删除、更改、插入节点的方法" class="headerlink" title="47.添加、删除、更改、插入节点的方法"></a>47.添加、删除、更改、插入节点的方法</h4><p>appendChild</p>
<p>removeChild</p>
<p>replaceChild</p>
<p>insertBefore</p>
<h4 id="48-在javascript编程中，请至少说出三种异步操作的使用场景？"><a href="#48-在javascript编程中，请至少说出三种异步操作的使用场景？" class="headerlink" title="48.在javascript编程中，请至少说出三种异步操作的使用场景？"></a>48.在javascript编程中，请至少说出三种异步操作的使用场景？</h4><p>回调函数</p>
<p>事件监听</p>
<p>Promise对象</p>
<p>Nodejs的异步方法</p>
<h4 id="49-知道不知道事件冒泡？知不知道阻止浏览器的默认行为？对应的原生兼容性写法该怎么写"><a href="#49-知道不知道事件冒泡？知不知道阻止浏览器的默认行为？对应的原生兼容性写法该怎么写" class="headerlink" title="49.知道不知道事件冒泡？知不知道阻止浏览器的默认行为？对应的原生兼容性写法该怎么写"></a>49.知道不知道事件冒泡？知不知道阻止浏览器的默认行为？对应的原生兼容性写法该怎么写</h4><p>事件冒泡</p>
<p>父元素和子元素上面的话都添加的有click（不仅仅是click事件，只要保证是同一个事件即可）。子元素的click事件触发的时候，会导致该click事件冒泡到它的父元素上面，为了阻止父元素的事件触发，我们一般需要给子元素的事件里写上阻止事件冒泡的方法</p>
<p>场景：（下拉菜单）点击空白区域关闭下拉菜单</p>
<p>兼容性写法：</p>
<p>if(event.stopPropagation){</p>
<p>​    event.stopPropagation();</p>
<p>}else if(event.cancelBubble){</p>
<p>​    event.cancelBubble = true;</p>
<p>}</p>
<p>阻止浏览器默认行为</p>
<p>当我们不希望一些浏览器默认行为触发的时候，就需要给对应的事件添加上阻止浏览器默认行为。</p>
<p>场景：</p>
<p>禁止a链接的点击后发生跳转</p>
<p>禁止UC等手机浏览器左右滑动切换到前一页或者下一页(我们可以通过给document的touchmove事件加上阻止浏览器默认行为的方法)</p>
<h4 id="50-什么是闭包（closure），为什么要用它？"><a href="#50-什么是闭包（closure），为什么要用它？" class="headerlink" title="50.什么是闭包（closure），为什么要用它？"></a>50.什么是闭包（closure），为什么要用它？</h4><p>闭包就是能够读取其他函数内部变量的函数，如果一个函数内部又定义了一个内部函数，并将该内部函数作为返回值返回或者存储在某个对象的属性里，这时就会形成一个闭包。</p>
<p>使用场景：1.匿名自执行函数   2缓存  3实现封装（封装的方式有很多，闭包只是其中一种，不是说到封装就一定会用闭包）</p>
<p>闭包的优缺点</p>
<p>闭包的优点：</p>
<p>1.缓存</p>
<p>2.面向对象中的对象</p>
<p>3.实现封装，防止变量跑到外层作用域中，发生命名冲突</p>
<p>4.匿名自执行函数，匿名自执行函数可以减小内存消耗</p>
<p>5.提升变量的作用域链</p>
<p>闭包的缺点：</p>
<p>1.闭包有一个非常严重的问题，那就是内存浪费问题，这个内存浪费不仅仅因为它常驻内存，更重要的是，对闭包的使用不当的话会造成无效内存的产生</p>
<p>2.性能问题 使用闭包时，会涉及到跨作用域访问，每次访问都会导致性能损失。</p>
<p>因此在脚本中，最好小心使用闭包，它同时会涉及到内存和速度问题。不过我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响。</p>
<h4 id="51-知道原型和原型链么，一般什么时候需要用？"><a href="#51-知道原型和原型链么，一般什么时候需要用？" class="headerlink" title="51.知道原型和原型链么，一般什么时候需要用？"></a>51.知道原型和原型链么，一般什么时候需要用？</h4><p>原型：</p>
<p>主要作用是用于继承</p>
<p>原型的作用是为函数对象声明通用的变量或者函数，构造函数的实例都会从原型上继承属性和方法。</p>
<p>每个对象中都有<strong>proto</strong>属性，这个属性指向的就是它基于的原型对象。</p>
<p>原型链：</p>
<p>var person = function(name){</p>
<p>   this.name = name</p>
<p>  };</p>
<p>  person.prototype.getName = function(){</p>
<p>​     return this.name;</p>
<p>  }</p>
<p>  var zjh = new person(‘zhangjiahao’);</p>
<p>  zjh.getName(); //zhangjiahao</p>
<p>JS在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做<strong>proto</strong>的内置属性，用于指向创建它的函数对象的原型对象prototype。以上面的例子为例：</p>
<p>  console.log(zjh.<strong>proto</strong> === person.prototype) //true</p>
<p>同样，person.prototype对象也有<strong>proto</strong>属性，它指向创建它的函数对象（Object）的prototype</p>
<p>  console.log(person.prototype.<strong>proto</strong> === Object.prototype)//true</p>
<p>继续，Object.prototype对象也有<strong>proto</strong>属性，但它比较特殊，为null</p>
<p>  console.log(Object.prototype.<strong>proto</strong>) //null</p>
<p>我们把这个有<strong>proto</strong>串起来的直到Object.prototype.<strong>proto</strong>为null的链叫做原型链</p>
<p>我们调用一个对象的属性或者方法的时候，会存在一个优先级的问题。优先级为：</p>
<p>构造函数内定义的属性&gt;构造函数的原型上定义的属性&gt;沿着<strong>proto</strong>指定的原型（原型链）一直往上找，直到找到null为止。任何一步一旦找到就立马停止，不会继续往下找。</p>
<h4 id="52-有没有封装过插件，你一般怎么封装呢"><a href="#52-有没有封装过插件，你一般怎么封装呢" class="headerlink" title="52.有没有封装过插件，你一般怎么封装呢"></a>52.有没有封装过插件，你一般怎么封装呢</h4><p>逼格低点的话这样说：</p>
<p>封装过，以前我主要是把一些公共的功能封装成函数来实现简单封装，比如tab切换封装的时候我会定义一个叫tab的函数，选项卡节点和内容节点作为函数tab的参数。假如我一个页面有多个tab切换，我只需要执行函数的时候给函数传入不同的参数即可。</p>
<p>逼格高点的这样说：</p>
<p>封装过，我们主要用面向对象中的混合模式来封装插件，把可变的属性或者方法（通常都是属性）在构造函数内定义，把一些不变的属性或者方法（通常是方法）定义在函数的原型上面。我们封装好的插件通常会放在一个匿名自执行函数里面，这样做的目的是为了避免变量冲突。</p>
<h4 id="53-Ajax和jsonp的原理？"><a href="#53-Ajax和jsonp的原理？" class="headerlink" title="53.Ajax和jsonp的原理？"></a>53.Ajax和jsonp的原理？</h4><p>Ajax的原理（最次最次也得把XMLHttpRequest对象说出来）</p>
<p>Ajax基于XMLHttpRequest对象与Web服务器端进行异步数据通信。</p>
<p>首先基于这个对象的open方法创建一个浏览器跟服务器端连接，通过send方法从浏览器向服务器端发送请求。我们可以通过这个对象的onreadystatechange事件来监听请求的状态，当请求成功之后的话，我可以获取到这个对象responseText等方法获取到请求过来的数据，然后通过js对这些数据进行解析</p>
<p>Jsonp原理</p>
<p>Ajax不能跨域，但是script标签和img标签都可以跨域。jsonp的话就是动态创建一个script标签，把jsonp数据格式(callback(json))的接口的地址赋值给我们的script标签的src属性。每一次发送jsonp请求的时候都会创建一个全局的回调函数，全局回调函数名称跟我们jsonp接口里面的函数名称是一致的。全局函数里面写的就是对请求过来数据的操作。</p>
<p>Ajax不能跨域，JSONP可以跨域。 </p>
<h4 id="54-你们移动端怎么开发的？用的什么单位、js框架呢、怎么真机调试你们程序、怎么解决前缀问题呢"><a href="#54-你们移动端怎么开发的？用的什么单位、js框架呢、怎么真机调试你们程序、怎么解决前缀问题呢" class="headerlink" title="54.你们移动端怎么开发的？用的什么单位、js框架呢、怎么真机调试你们程序、怎么解决前缀问题呢"></a>54.你们移动端怎么开发的？用的什么单位、js框架呢、怎么真机调试你们程序、怎么解决前缀问题呢</h4><p>首先我们移动端用的是rem这个单位，移动端实际上还新增了vw,vh等一些单位，但是相对于rem来说，他们的兼容性都不好。rem是一个相对单位，是相对于根节点的font-size的比例。我们还会引用一个外部的js，这个js可以通过屏幕宽度动态计算根节点的font-size值。</p>
<p>我们移动端用的JS框架是zepto.js，因为相应来说它的的体积的话要小很多。而且我们项目中有时会需要使用一些触屏事件，比如滑动事件，那么我们还会调用它里面的touch模块</p>
<p>我们webapp的话都是基于gulp搭建的前端工程来开发，因为利用gulp起一个webserver特别简单，并且我还可以实现livereload功能（当我监控的文件发生变化的时候，可以触发浏览器的自动刷新功能），而且在css3里面加前缀的话是一个很头疼的问题，我们现在只需要用autoprefixer模块就可以很容易实现自动加css3前缀这个功能了。</p>
<h4 id="55-移动端兼容性？"><a href="#55-移动端兼容性？" class="headerlink" title="55.移动端兼容性？"></a>55.移动端兼容性？</h4><p>1&gt;ios移动端click事件300ms的延迟响应. 用fastclick来解决</p>
<p>2&gt;zepto的touch模块的tap事件有点透的问题，也是用fastclick来解决</p>
<p>3&gt;一些情况下对非可点击元素如(label,span)监听click事件，ios下不会触发，css增加cursor:pointer就搞定了</p>
<p>4&gt;ios下取消input在输入的时候英文首字母的默认大写</p>
<p>&lt;input autocapitalize=”off”autocorrect=”off” /&gt;</p>
<p>5&gt;fixed定位缺陷</p>
<p>ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位</p>
<p>android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位</p>
<p>ios4下不支持position:fixed</p>
<p>解决方案： 可用iScroll插件解决这个问题</p>
<p>6&gt;Input 的placeholder会出现文本位置偏上的情况</p>
<p>input 的placeholder会出现文本位置偏上的情况：PC端设置line-height等于height能够对齐，而移动端仍然是偏上，解决是设置line-height：normal</p>
<p>7&gt;calc的兼容性处理</p>
<p>CSS3中的calc变量在iOS6浏览器中必须加-webkit-前缀，目前的FF浏览器已经无需-moz-前缀。</p>
<p>Android浏览器目前仍然不支持calc，所以要在之前增加一个保守尺寸：</p>
<p>div {</p>
<p>​    width: 95%;</p>
<p>​    width: -webkit-calc(100% - 50px);</p>
<p>​    width: calc(100% - 50px);</p>
<p>}</p>
<p>8&gt;在移动端修改难看的点击的高亮效果，iOS和安卓下都有效：</p>
<p>\ {-webkit-tap-highlight-color:rgba(0,0,0,0);}</p>
<p>9&gt;阻止旋转屏幕时自动调整字体大小</p>
<p>html, body, form, fieldset, p, div, h1, h2, h3, h4, h5,h6 {-webkit-text-size-adjust:none;}</p>
<h4 id="57-谈谈你对bootstrap的认识，用它做过项目么？"><a href="#57-谈谈你对bootstrap的认识，用它做过项目么？" class="headerlink" title="57.谈谈你对bootstrap的认识，用它做过项目么？"></a>57.谈谈你对bootstrap的认识，用它做过项目么？</h4><p>用Bootstrap主要用来做一些响应式的网站，它里面栅格化这块比较强大，我可以针对不同的屏幕尺寸定制不同页面结构。</p>
<p>我还用它做过后台管理系统，因为它里面集成的有风格标准统一的组件、插件、全局样式等，是我们做后台管理系统的话，不用再花大精力去布局页面了。而且甚至产品给我们一个原型图我们就可以开始开发，大大提高了开发效率。</p>
<h4 id="58-javascript-继承的-6-种方法？"><a href="#58-javascript-继承的-6-种方法？" class="headerlink" title="58.javascript 继承的 6 种方法？"></a>58.javascript 继承的 6 种方法？</h4><ol>
<li>原型链继承</li>
<li>借用构造函数继承</li>
<li>组合继承(原型+借用构造)</li>
<li>原型式继承</li>
<li>寄生式继承</li>
<li>寄生组合式继承</li>
</ol>
<h4 id="59-简述创建函数的几种方式"><a href="#59-简述创建函数的几种方式" class="headerlink" title="59.简述创建函数的几种方式"></a>59.简述创建函数的几种方式</h4><p>第一种（函数声明）：<br>function sum1(num1,num2){<br>return num1+num2;<br>}
第二种（函数表达式）：<br>var sum2 = function(num1,num2){<br>return num1+num2;<br>}
匿名函数：<br>function(){}:只能自己执行自己</p>
<h4 id="60-把-Script-标签-放在页面的最底部的-body-封闭之前-和封闭之后有什么区别？浏览器会如何解析它们？"><a href="#60-把-Script-标签-放在页面的最底部的-body-封闭之前-和封闭之后有什么区别？浏览器会如何解析它们？" class="headerlink" title="60.把 Script 标签 放在页面的最底部的 body 封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？"></a>60.把 Script 标签 放在页面的最底部的 body 封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？</h4><p>如果说放在 body 的封闭之前，将会阻塞其他资源的加载<br>如果放在 body 封闭之后，不会影响 body </p>
<h4 id="61-js-延迟加载的方式有哪些？"><a href="#61-js-延迟加载的方式有哪些？" class="headerlink" title="61.js 延迟加载的方式有哪些？"></a>61.js 延迟加载的方式有哪些？</h4><ol>
<li>defer 和 async</li>
<li>动态创建 DOM 方式（创建 script，插入到 DOM 中，加载完毕后 callBack）</li>
<li>按需异步载入 js</li>
</ol>
<h4 id="62-数组方法-pop-push-unshift-shift-各表示什么意思？"><a href="#62-数组方法-pop-push-unshift-shift-各表示什么意思？" class="headerlink" title="62.数组方法 pop() push() unshift() shift()各表示什么意思？"></a>62.数组方法 pop() push() unshift() shift()各表示什么意思？</h4><p>答：Push()尾部添加、pop()尾部删除、Unshift()头部添加、shift()头部删除</p>
<h4 id="63-Javascript-中-callee-和-caller-的作用？"><a href="#63-Javascript-中-callee-和-caller-的作用？" class="headerlink" title="63.Javascript 中 callee 和 caller 的作用？"></a>63.Javascript 中 callee 和 caller 的作用？</h4><p>caller 是返回一个对函数的引用，该函数调用了当前函数；<br>用法：fn.caller<br>callee 是返回正在被执行的 function 函数，也就是所指定的 function 对象的正文。<br>用法：arguments.callee</p>
<h4 id="64-jquery-extend-与-jquery-fn-extend-的区别？"><a href="#64-jquery-extend-与-jquery-fn-extend-的区别？" class="headerlink" title="64.jquery.extend 与 jquery.fn.extend 的区别？"></a>64.jquery.extend 与 jquery.fn.extend 的区别？</h4><p>Jquery.extend 用来扩展 jQuery 对象本身；jquery.fn.extend 用来扩展 jQuery 原型对象</p>
<h4 id="65-jQuery-和-Zepto-的区别？各自的使用场景？"><a href="#65-jQuery-和-Zepto-的区别？各自的使用场景？" class="headerlink" title="65.jQuery 和 Zepto 的区别？各自的使用场景？"></a>65.jQuery 和 Zepto 的区别？各自的使用场景？</h4><p>jQuery 主要用于 pc 端，当然有对应的 jQuerymobile 用于移动端，zepto 比 jQuery 更加小巧，主要用于移动端<br>jquer mobile 相对于 zepto 功能强大，但是体积也很庞大，zepto 非常的轻量</p>
<h4 id="66-Zepto-的点透问题如何解决？"><a href="#66-Zepto-的点透问题如何解决？" class="headerlink" title="66.Zepto 的点透问题如何解决？"></a>66.Zepto 的点透问题如何解决？</h4><p>点透主要是由于两个 div 重合，例如：一个 div 调用 show()，一个 div 调用 hide()；<br>这个时候当点击上面的 div 的时候就会影响到下面的那个 div；<br>解决办法主要有 2 种：<br>1.github 上有一个叫做 fastclick 的库，它也能规避移动设备上 click 事件的延迟响应，<a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">https://github.com/ftlabs/fastclick</a><br>将它用 script 标签引入页面（该库支持 AMD，于是你也可以按照 AMD 规范，用诸如require.js 的模块加载器引入），并且在 dom ready 时初始化在 body 上，<br>2.根据分析，如果不引入其它类库，也不想自己按照上述 fastclcik 的思路再开发一套东西，需要 1.一个优先于下面的“divClickUnder”捕获的事件；2.并且通过这个事件阻止掉默认行为（下面的“divClickUnder”对 click 事件的捕获，在 ios 的 safari，click 的捕获被认为和滚屏、点击输入框弹起键盘等一样，是一种浏览器默认行为，即可以被 event.preventDefault()阻止的行为）。</p>
<h4 id="67-事件绑定和普通事件有什么区别"><a href="#67-事件绑定和普通事件有什么区别" class="headerlink" title="67.事件绑定和普通事件有什么区别"></a>67.事件绑定和普通事件有什么区别</h4><p>传统事件绑定和符合 W3C 标准的事件绑定有什么区别？<br>div1.onclick=function(){};</p>
<p>1、如果说给同一个元素绑定了两次或者多次相同类型的事件，那么后面的绑定会覆盖前面的绑定<br>2、不支持 DOM 事件流 事件捕获阶段目标元素阶段=&gt;事件冒泡阶段</p>
<p>addEventListener<br>1、 如果说给同一个元素绑定了两次或者多次相同类型的事件，所有的绑定将会依次触发<br>2、 支持 DOM 事件流的<br>3、 进行事件绑定传参不需要 on 前缀</p>
<p>addEventListener(“click”,function(){},true);//此时的事件就是在事件冒泡阶段执行<br>ie9 开始，ie11 edge：addEventListener<br>ie9 以前：attachEvent/detachEvent<br>1、 进行事件类型传参需要带上 on 前缀<br>2、 这种方式只支持事件冒泡，不支持事件捕获<br>事件绑定是指把事件注册到具体的元素之上，普通事件指的是可以用来注册的事件</p>
<h4 id="68-IE-和标准下有哪些兼容性的写法"><a href="#68-IE-和标准下有哪些兼容性的写法" class="headerlink" title="68.IE 和标准下有哪些兼容性的写法"></a>68.IE 和标准下有哪些兼容性的写法</h4><p>var ev = ev || window.event<br>document.documentElement.clientWidth || document.body.clientWidth<br>var target = ev.srcElement||ev.target</p>
<h4 id="69-iframe-的优缺点？"><a href="#69-iframe-的优缺点？" class="headerlink" title="69.iframe 的优缺点？"></a>69.iframe 的优缺点？</h4><p>优点：</p>
<ol>
<li>解决加载缓慢的第三方内容如图标和广告等的加载问题</li>
<li>Security sandbox</li>
<li>并行加载脚本<br>缺点：</li>
<li>iframe 会阻塞主页面的 Onload 事件</li>
<li>即时内容为空，加载也需要时间</li>
<li>没有语意</li>
</ol>
<h4 id="70-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点"><a href="#70-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="70.DOM 操作——怎样添加、移除、移动、复制、创建和查找节点"></a>70.DOM 操作——怎样添加、移除、移动、复制、创建和查找节点</h4><ol>
<li>创建新节点<br>createDocumentFragment() // 创建一个 DOM 片段<br>createElement() // 创建一个具体的元素<br>createTextNode() // 创建一个文本节点</li>
<li>添加、移除、替换、插入<br>appendChild()<br>removeChild()<br>replaceChild()<br>insertBefore() // 在已有的子节点前插入一个新的子节点</li>
<li>查找<br>getElementsByTagName() // 通过标签名称<br>getElementsByName() // 通过元素的 Name 属性的值(IE 容错能力较强，会得到一个数组，<br>其中包括 id 等于 name 值的)<br>getElementById() // 通过元素 Id，唯一性</li>
</ol>
<h4 id="71-js-延迟加载的方式有哪些？"><a href="#71-js-延迟加载的方式有哪些？" class="headerlink" title="71.js 延迟加载的方式有哪些？"></a>71.js 延迟加载的方式有哪些？</h4><ol>
<li>defer 和 async</li>
<li>动态创建 DOM 方式（创建 script，插入到 DOM 中，加载完毕后 callBack）</li>
<li>按需异步载入 js</li>
</ol>
<h4 id="72-documen-write-和-innerHTML-的区别？"><a href="#72-documen-write-和-innerHTML-的区别？" class="headerlink" title="72.documen.write 和 innerHTML 的区别？"></a>72.documen.write 和 innerHTML 的区别？</h4><p>document.write 只能重绘整个页面<br>innerHTML 可以重绘页面的一部分</p>
<h4 id="73-哪些操作会造成内存泄漏？"><a href="#73-哪些操作会造成内存泄漏？" class="headerlink" title="73.哪些操作会造成内存泄漏？"></a>73.哪些操作会造成内存泄漏？</h4><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。<br>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p>
<ol>
<li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</li>
<li>闭包</li>
<li>控制台日志</li>
<li>循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li>
</ol>
<h4 id="74-window-location-search-返回的是什么？"><a href="#74-window-location-search-返回的是什么？" class="headerlink" title="74.window.location.search 返回的是什么？"></a>74.window.location.search 返回的是什么？</h4><p>答：查询(参数)部分。除了给动态语言赋值以外，我们同样可以给静态页面, 并使用 javascript 来获得相信应的参数值。<br>返回值：?ver=1.0&amp;id=timlq 也就是问号后面的！</p>
<h4 id="75-window-location-hash-返回的是什么？"><a href="#75-window-location-hash-返回的是什么？" class="headerlink" title="75.window.location.hash 返回的是什么？"></a>75.window.location.hash 返回的是什么？</h4><p>答：锚点</p>
<h4 id="76-window-location-reload-作用？"><a href="#76-window-location-reload-作用？" class="headerlink" title="76.window.location.reload() 作用？"></a>76.window.location.reload() 作用？</h4><p>答：刷新当前页面。</p>
<h4 id="77-BOM-对象有哪些，列举-window-对象？"><a href="#77-BOM-对象有哪些，列举-window-对象？" class="headerlink" title="77.BOM 对象有哪些，列举 window 对象？"></a>77.BOM 对象有哪些，列举 window 对象？</h4><p>1、window 对象 ，是 JS 的最顶层对象，其他的 BOM 对象都是 window 对象的属性；<br>2、document 对象，文档对象；<br>3、location 对象，浏览器当前 URL 信息；<br>4、navigator 对象，浏览器本身信息；<br>5、screen 对象，客户端屏幕信息；<br>6、history 对象，浏览器访问历史信息；</p>
<h4 id="78-请问代码实现-outerHTML"><a href="#78-请问代码实现-outerHTML" class="headerlink" title="78.请问代码实现 outerHTML"></a>78.请问代码实现 outerHTML</h4><p>说明：outerHTML 其实就是 innerHTML 再加上本身；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.outerHTML = function()&#123;</span><br><span class="line">    var innerCon = this.innerHTML, //获得里面的内容</span><br><span class="line">    outerCon = this.appendChild(innerCon); //添加到里面</span><br><span class="line">    alert(outerCon);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="79-你如何优化自己的代码？"><a href="#79-你如何优化自己的代码？" class="headerlink" title="79.你如何优化自己的代码？"></a>79.你如何优化自己的代码？</h4><p>代码重用<br>避免全局变量（命名空间，封闭空间，模块化 mvc..）<br>拆分函数避免函数过于臃肿：单一职责原则<br>适当的注释，尤其是一些复杂的业务逻辑或者是计算逻辑，都应该写出这个业务逻辑的具体过程<br>内存管理，尤其是闭包中的变量释放</p>
<h4 id="80-列举常用的-js-框架以及分别适用的领域"><a href="#80-列举常用的-js-框架以及分别适用的领域" class="headerlink" title="80.列举常用的 js 框架以及分别适用的领域"></a>80.列举常用的 js 框架以及分别适用的领域</h4><p>jquery：简化了 js 的一些操作，并且提供了一些非常好用的 API<br>jquery ui、jquery-easyui：在 jqeury 的基础上提供了一些常用的组件 日期，下拉框，表格这<br>些组件<br>require.js、sea.js（阿里的玉帛）+》模块化开发使用的<br>zepto：精简版的 jquery，常用于手机 web 前端开发 提供了一些手机页面实用功能,touch<br>ext.js：跟 jquery 差不多，但是不开源，也没有 jquery 轻量<br>angular、knockoutjs、avalon(去哪儿前端总监)：MV*框架，适合用于单页应用开发(SPA)</p>
<h4 id="81-JavaScript-数组元素添加、删除、排序等方法有哪些？"><a href="#81-JavaScript-数组元素添加、删除、排序等方法有哪些？" class="headerlink" title="81.JavaScript 数组元素添加、删除、排序等方法有哪些？"></a>81.JavaScript 数组元素添加、删除、排序等方法有哪些？</h4><p>Array.concat( ) 连接数组<br>Array.join( ) 将数组元素连接起来以构建一个字符串<br>Array.length 数组的大小<br>Array.pop( ) 删除并返回数组的最后一个元素<br>Array.push( ) 给数组添加元素<br>Array.reverse( ) 颠倒数组中元素的顺序<br>Array.shift( ) 将元素移出数组<br>Array.slice( ) 返回数组的一部分<br>Array.sort( ) 对数组元素进行排序<br>Array.splice( ) 插入、删除或替换数组的元素<br>Array.toLocaleString( ) 把数组转换成局部字符串<br>Array.toString( ) 将数组转换成一个字符串<br>Array.unshift( ) 在数组头部插入一个元素</p>
<h4 id="82-如何添加-html-元素的事件，有几种方法？请列举"><a href="#82-如何添加-html-元素的事件，有几种方法？请列举" class="headerlink" title="82.如何添加 html 元素的事件，有几种方法？请列举"></a>82.如何添加 html 元素的事件，有几种方法？请列举</h4><p>a、直接在标签里添加：这是一个层<br>b、在元素上通过 js 添加:<br>c、使用事件注册函数添加</p>
<h4 id="83-使用闭包实现点击每一列的时候-alert-其-index？"><a href="#83-使用闭包实现点击每一列的时候-alert-其-index？" class="headerlink" title="83.使用闭包实现点击每一列的时候 alert 其 index？"></a>83.使用闭包实现点击每一列的时候 alert 其 index？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;test&quot;&gt;</span><br><span class="line">    &lt;li&gt;这是第一条&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;这是第二条&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;这是第三条&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">var lis=document.querySelectorAll(&apos;li&apos;);</span><br><span class="line">for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">    var li = lis[i];</span><br><span class="line">    li.onclick=(function(index)&#123;</span><br><span class="line">        return function(e)&#123;</span><br><span class="line">        alert(index);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="84-列出-3-条以上-ff-和-IE-的脚本兼容问题"><a href="#84-列出-3-条以上-ff-和-IE-的脚本兼容问题" class="headerlink" title="84.列出 3 条以上 ff 和 IE 的脚本兼容问题"></a>84.列出 3 条以上 ff 和 IE 的脚本兼容问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1、在 IE 下和火狐下事件冒泡不一样</span><br><span class="line"></span><br><span class="line">2、IE 的写法： tbody=table.childNodes[0]</span><br><span class="line">	在 FF 中，firefox 会在子节点中包含空白则第一个子节点为空白&quot;&quot;， 而 ie 不会返回空白</span><br><span class="line">	可以通过 if(&quot;&quot; != node.nodeName)过滤掉空白子对象</span><br><span class="line"></span><br><span class="line">3、模拟点击事件</span><br><span class="line">if(document.all)&#123; //ie 下</span><br><span class="line">	document.getElementById(&quot;a3&quot;).click();</span><br><span class="line">&#125;</span><br><span class="line">else&#123; //非 IE</span><br><span class="line">	var evt = document.createEvent(&quot;MouseEvents&quot;);</span><br><span class="line">	evt.initEvent(&quot;click&quot;, true, true);</span><br><span class="line">	document.getElementById(&quot;a3&quot;).dispatchEvent(evt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4、事件注册</span><br><span class="line">if (isIE)&#123;window.attachEvent(&quot;onload&quot;, init);&#125;else&#123;window.addEventListener(&quot;load&quot;, </span><br><span class="line"></span><br><span class="line">5、ajax对象的获取</span><br><span class="line"></span><br><span class="line">6、firstElement等返回结果不一样</span><br></pre></td></tr></table></figure>

<h4 id="85-在-Javascript-中什么是伪数组？如何将伪数组转化为标准数组？"><a href="#85-在-Javascript-中什么是伪数组？如何将伪数组转化为标准数组？" class="headerlink" title="85.在 Javascript 中什么是伪数组？如何将伪数组转化为标准数组？"></a>85.在 Javascript 中什么是伪数组？如何将伪数组转化为标准数组？</h4><p>伪数组（类数组）：无法直接调用数组方法或期望 length 属性有什么特殊的行为，但仍可<br>以对真正数组遍历方法来遍历它们。典型的是函数的 argument 参数，还有像调用<br>getElementsByTagName,document.childNodes 之类的,它们都返回 NodeList 对象都属于伪<br>数组。<br>可以使用 Array.prototype.slice.call(fakeArray)将数组转化为真正的 Array 对象。</p>
<h4 id="86-正则表达式构造函数-var-reg-new-RegExp-“xxx”-与正则表达字面量-var"><a href="#86-正则表达式构造函数-var-reg-new-RegExp-“xxx”-与正则表达字面量-var" class="headerlink" title="86.正则表达式构造函数 var reg=new RegExp(“xxx”)与正则表达字面量 var"></a>86.正则表达式构造函数 var reg=new RegExp(“xxx”)与正则表达字面量 var</h4><p>reg=//有什么不同？匹配邮箱的正则表达式？<br>答案：当使用 RegExp()构造函数的时候，不仅需要转义引号（即\”表示”），并且还需要<br>双反斜杠（即\表示一个\）。使用正则表达字面量的效率更高。</p>
<h4 id="87-jQuery-的-slideUp-动画-，如果目标元素是被外部事件驱动-当鼠标快速地连续触发外部元素事件-动画会滞后的反复执行，该如何处理呢"><a href="#87-jQuery-的-slideUp-动画-，如果目标元素是被外部事件驱动-当鼠标快速地连续触发外部元素事件-动画会滞后的反复执行，该如何处理呢" class="headerlink" title="87.jQuery 的 slideUp 动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?"></a>87.jQuery 的 slideUp 动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?</h4><p>先 stop(true,true)后 slideUp()</p>
<h4 id="88-javascript-的本地对象，内置对象和宿主对象"><a href="#88-javascript-的本地对象，内置对象和宿主对象" class="headerlink" title="88.javascript 的本地对象，内置对象和宿主对象"></a>88.javascript 的本地对象，内置对象和宿主对象</h4><p>本地对象为独立于宿主环境的 ECMAScript 提供的对象，包括 Array Object RegExp 等可以 new 实例化的对象<br>内置对象为 Gload，Math 等不可以实例化的(他们也是本地对象，内置对象是本地对象的一个子集)<br>宿主对象为所有的非本地对象，所有的 BOM 和 DOM 对象都是宿主对象，如浏览器自带的document,window 等对象</p>
<h4 id="89-请说出三种减低页面加载时间的方法"><a href="#89-请说出三种减低页面加载时间的方法" class="headerlink" title="89.请说出三种减低页面加载时间的方法"></a>89.请说出三种减低页面加载时间的方法</h4><p>1、压缩 css、js 文件<br>2、合并 js、css 文件，减少 http 请求<br>3、外部 js、css 文件放在最底下<br>4、减少 dom 操作，尽可能用变量替代不必要的 dom 操作</p>
<h4 id="90-Javascript-作用域链"><a href="#90-Javascript-作用域链" class="headerlink" title="90.Javascript 作用域链?"></a>90.Javascript 作用域链?</h4><p>JavaScript有全局作用域和局部作用域，没有块作用域，函数的嵌套形成不同层次的作用域，嵌套的层次形成链式形式，通过作用域链查找属性的规则需要深入理解。</p>
<h4 id="91-eval-是做什么的？"><a href="#91-eval-是做什么的？" class="headerlink" title="91. eval 是做什么的？"></a>91. eval 是做什么的？</h4><p>它的功能是把对应的字符串解析成 JS 代码并运行；应该避免使用 eval，不安全，非常耗性能（2 个步骤，一次解析成 js 语句，一次执行）</p>
<h4 id="92-javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？"><a href="#92-javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？" class="headerlink" title="92.javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？"></a>92.javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</h4><p>意思是使用严格模式，使用严格模式，一些不规范的语法将不再支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">链接：http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html</span><br><span class="line">全局变量显式声明</span><br><span class="line">静态绑定</span><br><span class="line">禁止使用 with 语句</span><br><span class="line">eval 中定义的变量都是局部变量</span><br><span class="line">禁止 this 关键字指向全局对象</span><br><span class="line">禁止在函数内部遍历调用栈</span><br><span class="line">严格模式下无法删除变量。只有 configurable 设置为 true 的对象属性，才能被删除</span><br><span class="line">正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，</span><br><span class="line">将报错。</span><br><span class="line">严格模式下，对一个使用 getter 方法读取的属性进行赋值，会报错。</span><br><span class="line">严格模式下，对禁止扩展的对象添加新属性，会报错。</span><br><span class="line">严格模式下，删除一个不可删除的属性，会报错。</span><br><span class="line">正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，</span><br><span class="line">这属于语法错误。</span><br><span class="line">正常模式下，如果函数有多个重名的参数，可以用 arguments[i]读取。严格模式下，这属于</span><br><span class="line">语法错误。</span><br><span class="line">正常模式下，整数的第一位如果是 0，表示这是八进制数，比如 0100 等于十进制的 64。严</span><br><span class="line">格模式禁止这种表示法，整数第一位为 0，将报错。</span><br><span class="line">不允许对 arguments 赋值</span><br><span class="line">arguments 不再追踪参数的变化</span><br><span class="line">禁止使用 arguments.callee</span><br><span class="line">严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的</span><br><span class="line">代码块内声明函数</span><br><span class="line">严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。</span><br></pre></td></tr></table></figure>

<h4 id="93-Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"><a href="#93-Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？" class="headerlink" title="93.Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"></a>93.Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</h4><p>HasOwnProperty</p>
<h4 id="94-js模块化规范"><a href="#94-js模块化规范" class="headerlink" title="94.js模块化规范"></a>94.js模块化规范</h4><p>浏览器端 requirejs，seajs；</p>
<p>服务器端 commonJS；</p>
<p>ES6 模块化；fis</p>
<h4 id="95-gulp、grunt、webpack"><a href="#95-gulp、grunt、webpack" class="headerlink" title="95.gulp、grunt、webpack"></a>95.gulp、grunt、webpack</h4><p>gulp、grunt、webpack都是前端自动化构建工具。gulp 和 grunt 非常类似，gulp强调的是前端开发的工作流程，核心都是基于一个个的任务(task)进行项目构建，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程</p>
<p>Webpack与Gulp、Grunt没有什么可比性，它把项目看成一个整体，是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。webpack is a module bundle</p>
<h4 id="96-requireJS-的核心原理是什么？"><a href="#96-requireJS-的核心原理是什么？" class="headerlink" title="96.requireJS 的核心原理是什么？"></a>96.requireJS 的核心原理是什么？</h4><p>核心是 js 的加载模块，通过正则匹配模块以及模块的依赖关系，保证文件加载的先后顺序，根据文件的路径对加载过的文件做了缓存</p>
<h4 id="97-AMD（Modules-Asynchronous-Definition）、CMD（Common-Module-Definition）"><a href="#97-AMD（Modules-Asynchronous-Definition）、CMD（Common-Module-Definition）" class="headerlink" title="97.AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）"></a>97.AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）</h4><p>规范区别？<br>理解这两种规范的差异，主要通过 requirejs 与 seajs 的对比，理解模块的定义与引用方式<br>的差异以及这两种规范的设计原则<br>参考链接 1：<a href="https://www.zhihu.com/question/20351507/answer/14859415" target="_blank" rel="noopener">https://www.zhihu.com/question/20351507/answer/14859415</a><br>参考链接 2：<a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="noopener">https://github.com/seajs/seajs/issues/277</a></p>
<p>1、对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，<br>也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.<br>2、CMD 推崇依赖就近，AMD 推崇依赖前置。</p>
<p>3、AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个API 都简单纯粹。</p>
<h4 id="98-谈一谈你对-ECMAScript6-的了解"><a href="#98-谈一谈你对-ECMAScript6-的了解" class="headerlink" title="98.谈一谈你对 ECMAScript6 的了解"></a>98.谈一谈你对 ECMAScript6 的了解</h4><p>ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。</p>
<p>新特性：变量声明(let const)、解构赋值、字符串扩展(模板字符串)、函数扩展(箭头函数)、数组扩展、对象扩展、Symbol、数据结构(Array\Set\Map)、代理反射、类(Class)、Promise、迭代器(Iterator)、生成器(Generator)</p>
<h4 id="99-Object-对象的常用方法"><a href="#99-Object-对象的常用方法" class="headerlink" title="99.Object 对象的常用方法"></a>99.Object 对象的常用方法</h4><p>Object.hasOwnProperty( ) 检查属性是否被继承<br>Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型<br>Object.propertyIsEnumerable( ) 是否可以通过 for/in 循环看到属性<br>Object.toLocaleString( ) 返回对象的本地字符串表示<br>Object.toString( ) 定义一个对象的字符串表示<br>Object.valueOf( )  指定对象的原始值</p>
<h4 id="100-如何编写高性能的-Javascript？"><a href="#100-如何编写高性能的-Javascript？" class="headerlink" title="100.如何编写高性能的 Javascript？"></a>100.如何编写高性能的 Javascript？</h4><p>使用 DocumentFragment 优化多次 append<br>通过模板元素 clone ，替代 createElement<br>使用一次 innerHTML 赋值代替构建 dom 元素<br>使用 firstChild 和 nextSibling 代替 childNodes 遍历 dom 元素<br>使用 Array 做为 StringBuffer ，代替字符串拼接的操作<br>将循环控制量保存到局部变量<br>顺序无关的遍历时，用 while 替代 for<br>将条件分支，按可能性顺序从高到低排列<br>在同一条件子的多（ &gt;2 ）条件分支时，使用 switch 优于 if<br>使用三目运算符替代条件分支<br>需要不断执行的时候，优先考虑使用 setInterval</p>
<h4 id="101-说说你对-this-的理解？"><a href="#101-说说你对-this-的理解？" class="headerlink" title="101.说说你对 this 的理解？"></a>101.说说你对 this 的理解？</h4><p>在 JavaScript 中，this 通常指向的是我们正在执行的函数本身，或者是，指向该函数所属的对象。<br>全局的 this → 指向的是 Window<br>函数中的 this → 指向的是函数调用者<br>对象中的 this → 指向其本身<br>事件中 this → 指向事件对象</p>
<h4 id="102-分别阐述-split-slice-splice-join-？"><a href="#102-分别阐述-split-slice-splice-join-？" class="headerlink" title="102.分别阐述 split(),slice(),splice(),join()？"></a>102.分别阐述 split(),slice(),splice(),join()？</h4><p>join()用于把数组中的所有元素拼接起来放入一个字符串。所带的参数为分割字符串的分隔<br>符，默认是以逗号分开。归属于 Array<br>split()即把字符串分离开，以数组方式存储。归属于 Stringstring<br>slice() 方法可从已有的数组中返回选定的元素。该方法并不会修改数组，而是返回一个子<br>数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()<br>splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。返回的是含有被删除<br>的元素的数组。</p>
<h4 id="103-jQuery-fn-的-init-方法返回的-this-指的是什么对象？为什么要返回-this？"><a href="#103-jQuery-fn-的-init-方法返回的-this-指的是什么对象？为什么要返回-this？" class="headerlink" title="103.jQuery.fn 的 init 方法返回的 this 指的是什么对象？为什么要返回 this？"></a>103.jQuery.fn 的 init 方法返回的 this 指的是什么对象？为什么要返回 this？</h4><p>this 执行 init 构造函数自身，其实就是 jQuery 实例对象，返回 this 是为了实现 jQuery<br>的链式操作</p>
<h4 id="104-js中如何将数组转化为-json-字符串，然后再转化回来？"><a href="#104-js中如何将数组转化为-json-字符串，然后再转化回来？" class="headerlink" title="104.js中如何将数组转化为 json 字符串，然后再转化回来？"></a>104.js中如何将数组转化为 json 字符串，然后再转化回来？</h4><p>JSON.parse()<br>JSON.stringify()</p>
<h4 id="105-jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝？"><a href="#105-jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝？" class="headerlink" title="105.jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？"></a>105.jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？</h4><p>递归赋值</p>

    </div>

    

    

    <!-- Comments -->
    

</div>
        </section>

    </div>
</div>


</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a href="https://github.com/klugjo">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2019/06/10/CSS/">Untitled</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/06/10/JavaSciprt/">Untitled</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/06/10/HTTP/">Untitled</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/06/10/HTML/">Untitled</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klugjo/hexo-theme-alpha-dust">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://twitter.com/?lang=en">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.facebook.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.instagram.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://dribbble.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://plus.google.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-google-plus"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.behance.net/">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://500px.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>
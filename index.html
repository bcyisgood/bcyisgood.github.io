<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.8.0">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="John Doe">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Hexo">
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Hexo">

    <!--Type page-->
    
        <meta property="og:type" content="website">
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary">
    

    <!-- Title -->
    
    <title>Hexo</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">Hexo</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/06/10/CSS/">
                Untitled
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-06-10</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h4 id="1-CSS-选择器的优先级是如何计算的？"><a href="#1-CSS-选择器的优先级是如何计算的？" class="headerlink" title="1.CSS 选择器的优先级是如何计算的？"></a>1.CSS 选择器的优先级是如何计算的？</h4><p>浏览器通过优先级规则，判断元素展示哪些样式。优先级通过 4 个维度指标确定，我们假定以<code>a、b、c、d</code>命名，分别代表以下含义：</p>
<ol>
<li><code>a</code>表示是否使用内联样式（inline style）。如果使用，<code>a</code>为 1，否则为 0。</li>
<li><code>b</code>表示 ID 选择器的数量。</li>
<li><code>c</code>表示类选择器、属性选择器和伪类选择器数量之和。</li>
<li><code>d</code>表示标签（类型）选择器和伪元素选择器之和。</li>
</ol>
<p>优先级的结果并非通过以上四个值生成一个得分，而是每个值分开比较。<code>a、b、c、d</code>权重从左到右，依次减小。判断优先级时，从左到右，一一比较，直到比较出最大值，即可停止。所以，如果<code>b</code>的值不同，那么<code>c</code>和<code>d</code>不管多大，都不会对结果产生影响。比如<code>0，1，0，0</code>的优先级高于<code>0，0，10，10</code>。</p>
<p>当出现优先级相等的情况时，最晚出现的样式规则会被采纳。如果你在样式表里写了相同的规则（无论是在该文件内部还是其它样式文件中），那么最后出现的（在文件底部的）样式优先级更高，因此会被采纳。</p>
<p>在写样式时，我会使用较低的优先级，这样这些样式可以轻易地覆盖掉。尤其对写 UI 组件的时候更为重要，这样使用者就不需要通过非常复杂的优先级规则或使用<code>!important</code>的方式，去覆盖组件的样式了。</p>
<ul>
<li><a href="https://www.smashingmagazine.com/2007/07/css-specificity-things-you-should-know/" target="_blank" rel="noopener">https://www.smashingmagazine.com/2007/07/css-specificity-things-you-should-know/</a></li>
<li><a href="https://www.sitepoint.com/web-foundations/specificity/" target="_blank" rel="noopener">https://www.sitepoint.com/web-foundations/specificity/</a></li>
</ul>
<h4 id="2-重置（resetting）CSS-和-标准化（normalizing）CSS-的区别是什么？你会选择哪种方式，为什么？"><a href="#2-重置（resetting）CSS-和-标准化（normalizing）CSS-的区别是什么？你会选择哪种方式，为什么？" class="headerlink" title="2.重置（resetting）CSS 和 标准化（normalizing）CSS 的区别是什么？你会选择哪种方式，为什么？"></a>2.重置（resetting）CSS 和 标准化（normalizing）CSS 的区别是什么？你会选择哪种方式，为什么？</h4><ul>
<li>重置（Resetting）： 重置意味着除去所有的浏览器默认样式。对于页面所有的元素，像<code>margin</code>、<code>padding</code>、<code>font-size</code>这些样式全部置成一样。你将必须重新定义各种元素的样式。</li>
<li>标准化（Normalizing）： 标准化没有去掉所有的默认样式，而是保留了有用的一部分，同时还纠正了一些常见错误。</li>
</ul>
<p>当需要实现非常个性化的网页设计时，我会选择重置的方式，因为我要写很多自定义的样式以满足设计需求，这时候就不再需要标准化的默认样式了。</p>
<ul>
<li><a href="https://stackoverflow.com/questions/6887336/what-is-the-difference-between-normalize-css-and-reset-css" target="_blank" rel="noopener">https://stackoverflow.com/questions/6887336/what-is-the-difference-between-normalize-css-and-reset-css</a></li>
</ul>
<h4 id="3-请阐述Float定位的工作原理。"><a href="#3-请阐述Float定位的工作原理。" class="headerlink" title="3.请阐述Float定位的工作原理。"></a>3.请阐述<code>Float</code>定位的工作原理。</h4><p>浮动（float）是 CSS 定位属性。浮动元素从网页的正常流动中移出，但是保持了部分的流动性，会影响其他元素的定位（比如文字会围绕着浮动元素）。这一点与绝对定位不同，绝对定位的元素完全从文档流中脱离。</p>
<p>CSS 的<code>clear</code>属性通过使用<code>left</code>、<code>right</code>、<code>both</code>，让该元素向下移动（清除浮动）到浮动元素下面。</p>
<p>如果父元素只包含浮动元素，那么该父元素的高度将塌缩为 0。我们可以通过清除（clear）从浮动元素后到父元素关闭前之间的浮动来修复这个问题。</p>
<p>有一种 hack 的方法，是自定义一个<code>.clearfix</code>类，利用伪元素选择器<code>::after</code>清除浮动。<a href="https://css-tricks.com/all-about-floats/#article-header-id-4" target="_blank" rel="noopener">另外还有一些方法</a>，比如添加空的<code>&lt;div&gt;&lt;/div&gt;</code>和设置浮动元素父元素的<code>overflow</code>属性。与这些方法不同的是，<code>clearfix</code>方法，只需要给父元素添加一个类，定义如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得一提的是，把父元素属性设置为<code>overflow: auto</code>或<code>overflow: hidden</code>，会使其内部的子元素形成块格式化上下文（Block Formatting Context），并且父元素会扩张自己，使其能够包围它的子元素。</p>
<ul>
<li><a href="https://css-tricks.com/all-about-floats/" target="_blank" rel="noopener">https://css-tricks.com/all-about-floats/</a></li>
</ul>
<h4 id="4-请阐述z-index属性，并说明如何形成层叠上下文（stacking-context）。"><a href="#4-请阐述z-index属性，并说明如何形成层叠上下文（stacking-context）。" class="headerlink" title="4.请阐述z-index属性，并说明如何形成层叠上下文（stacking context）。"></a>4.请阐述<code>z-index</code>属性，并说明如何形成层叠上下文（stacking context）。</h4><p>CSS 中的<code>z-index</code>属性控制重叠元素的垂直叠加顺序。<code>z-index</code>只能影响<code>position</code>值不是<code>static</code>的元素。</p>
<p>没有定义<code>z-index</code>的值时，元素按照它们出现在 DOM 中的顺序堆叠（层级越低，出现位置越靠上）。非静态定位的元素（及其子元素）将始终覆盖静态定位（static）的元素，而不管 HTML 层次结构如何。</p>
<p>层叠上下文是包含一组图层的元素。 在一组层叠上下文中，其子元素的<code>z-index</code>值是相对于该父元素而不是 document root 设置的。每个层叠上下文完全独立于它的兄弟元素。如果元素 B 位于元素 A 之上，则即使元素 A 的子元素 C 具有比元素 B 更高的<code>z-index</code>值，元素 C 也永远不会在元素 B 之上.</p>
<p>每个层叠上下文是自包含的：当元素的内容发生层叠后，整个该元素将会在父层叠上下文中按顺序进行层叠。少数 CSS 属性会触发一个新的层叠上下文，例如<code>opacity</code>小于 1，<code>filter</code>不是<code>none</code>，<code>transform</code>不是<code>none</code>。</p>
<ul>
<li><a href="https://css-tricks.com/almanac/properties/z/z-index/" target="_blank" rel="noopener">https://css-tricks.com/almanac/properties/z/z-index/</a></li>
<li><a href="https://philipwalton.com/articles/what-no-one-told-you-about-z-index/" target="_blank" rel="noopener">https://philipwalton.com/articles/what-no-one-told-you-about-z-index/</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context</a></li>
</ul>
<h4 id="5-请阐述块格式化上下文（Block-Formatting-Context）及其工作原理。"><a href="#5-请阐述块格式化上下文（Block-Formatting-Context）及其工作原理。" class="headerlink" title="5.请阐述块格式化上下文（Block Formatting Context）及其工作原理。"></a>5.请阐述块格式化上下文（Block Formatting Context）及其工作原理。</h4><p>块格式上下文（BFC）是 Web 页面的可视化 CSS 渲染的部分，是块级盒布局发生的区域，也是浮动元素与其他元素交互的区域。</p>
<p>一个 HTML 盒（Box）满足以下任意一条，会创建块格式化上下文：</p>
<ul>
<li><code>float</code>的值不是<code>none</code>.</li>
<li><code>position</code>的值不是<code>static</code>或<code>relative</code>.</li>
<li><code>display</code>的值是<code>table-cell</code>、<code>table-caption</code>、<code>inline-block</code>、<code>flex</code>、或<code>inline-flex</code>。</li>
<li><code>overflow</code>的值不是<code>visible</code>。</li>
</ul>
<p>在 BFC 中，每个盒的左外边缘都与其包含的块的左边缘相接。</p>
<p>两个相邻的块级盒在垂直方向上的边距会发生合并（collapse）。更多内容请参考<a href="https://www.sitepoint.com/web-foundations/collapsing-margins/" target="_blank" rel="noopener">边距合并（margin collapsing）</a>。</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context</a></li>
<li><a href="https://www.sitepoint.com/understanding-block-formatting-contexts-in-css/" target="_blank" rel="noopener">https://www.sitepoint.com/understanding-block-formatting-contexts-in-css/</a></li>
</ul>
<h4 id="6-有哪些清除浮动的技术，都适用哪些情况？"><a href="#6-有哪些清除浮动的技术，都适用哪些情况？" class="headerlink" title="6.有哪些清除浮动的技术，都适用哪些情况？"></a>6.有哪些清除浮动的技术，都适用哪些情况？</h4><ul>
<li>空<code>div</code>方法：<code>&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;</code>。</li>
<li>Clearfix 方法：上文使用<code>.clearfix</code>类已经提到。</li>
<li><code>overflow: auto</code>或<code>overflow: hidden</code>方法：上文已经提到。</li>
</ul>
<p>在大型项目中，我会使用 Clearfix 方法，在需要的地方使用<code>.clearfix</code>。设置<code>overflow: hidden</code>的方法可能使其子元素显示不完整，当子元素的高度大于父元素时。</p>
<h4 id="7-请解释什么是雪碧图（css-sprites），以及如何实现？"><a href="#7-请解释什么是雪碧图（css-sprites），以及如何实现？" class="headerlink" title="7.请解释什么是雪碧图（css sprites），以及如何实现？"></a>7.请解释什么是雪碧图（css sprites），以及如何实现？</h4><p>雪碧图是把多张图片整合到一张上的图片。它被运用在众多使用了很多小图标的网站上（Gmail 在使用）。实现方法：</p>
<ol>
<li>使用生成器将多张图片打包成一张雪碧图，并为其生成合适的 CSS。</li>
<li>每张图片都有相应的 CSS 类，该类定义了<code>background-image</code>、<code>background-position</code>和<code>background-size</code>属性。</li>
<li>使用图片时，将相应的类添加到你的元素中。</li>
</ol>
<p>好处：</p>
<ul>
<li>减少加载多张图片的 HTTP 请求数（一张雪碧图只需要一个请求）。但是对于 HTTP2 而言，加载多张图片不再是问题。</li>
<li>提前加载资源，防止在需要时才在开始下载引发的问题，比如只出现在<code>:hover</code>伪类中的图片，不会出现闪烁。</li>
</ul>
<p><a href="https://css-tricks.com/css-sprites/" target="_blank" rel="noopener">https://css-tricks.com/css-sprites/</a></p>
<h4 id="8-如何解决不同浏览器的样式兼容性问题？"><a href="#8-如何解决不同浏览器的样式兼容性问题？" class="headerlink" title="8.如何解决不同浏览器的样式兼容性问题？"></a>8.如何解决不同浏览器的样式兼容性问题？</h4><ul>
<li>在确定问题原因和有问题的浏览器后，使用单独的样式表，仅供出现问题的浏览器加载。这种方法需要使用服务器端渲染。</li>
<li>使用已经处理好此类问题的库，比如 Bootstrap。</li>
<li>使用 <code>autoprefixer</code> 自动生成 CSS 属性前缀。</li>
<li>使用 Reset CSS 或 Normalize.css。</li>
</ul>
<h4 id="9-如何为功能受限的浏览器提供页面？-使用什么样的技术和流程？"><a href="#9-如何为功能受限的浏览器提供页面？-使用什么样的技术和流程？" class="headerlink" title="9.如何为功能受限的浏览器提供页面？ 使用什么样的技术和流程？"></a>9.如何为功能受限的浏览器提供页面？ 使用什么样的技术和流程？</h4><ul>
<li>优雅的降级：为现代浏览器构建应用，同时确保它在旧版浏览器中正常运行。</li>
<li>Progressive enhancement - The practice of building an application for a base level of user experience, but adding functional enhancements when a browser supports it.</li>
<li>渐进式增强：构建基于用户体验的应用，但在浏览器支持时添加新增功能。</li>
<li>利用 <a href="https://caniuse.com/" target="_blank" rel="noopener">caniuse.com</a> 检查特性支持。</li>
<li>使用 <code>autoprefixer</code> 自动生成 CSS 属性前缀。</li>
<li>使用 <a href="https://modernizr.com/" target="_blank" rel="noopener">Modernizr</a>进行特性检测。</li>
</ul>
<h4 id="10-有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？"><a href="#10-有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？" class="headerlink" title="10.有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？"></a>10.有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？</h4><p>这些方法与可访问性（a11y）有关。</p>
<ul>
<li><code>visibility: hidden</code>：元素仍然在页面流中，并占用空间。</li>
<li><code>width: 0; height: 0</code>：使元素不占用屏幕上的任何空间，导致不显示它。</li>
<li><code>position: absolute; left: -99999px</code>： 将它置于屏幕之外。</li>
<li><code>text-indent: -9999px</code>：这只适用于<code>block</code>元素中的文本。</li>
<li>Metadata： 例如通过使用 Schema.org，RDF 和 JSON-LD。</li>
<li>WAI-ARIA：如何增加网页可访问性的 W3C 技术规范。</li>
</ul>
<p>即使 WAI-ARIA 是理想的解决方案，我也会采用绝对定位方法，因为它具有最少的注意事项，适用于大多数元素，而且使用起来非常简单。</p>
<p><a href="https://www.w3.org/TR/wai-aria-1.1/" target="_blank" rel="noopener">https://www.w3.org/TR/wai-aria-1.1/</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA</a></p>
<p><a href="http://a11yproject.com/" target="_blank" rel="noopener">http://a11yproject.com/</a></p>
<h4 id="11-除了screen，你还能说出一个-media-属性的例子吗？"><a href="#11-除了screen，你还能说出一个-media-属性的例子吗？" class="headerlink" title="11.除了screen，你还能说出一个 @media 属性的例子吗？"></a>11.除了<code>screen</code>，你还能说出一个 @media 属性的例子吗？</h4><ul>
<li>all<br><br>适用于所有设备。</li>
<li>print<br><br>为了加载合适的文档到当前使用的可视窗口. 需要提前咨询 paged media（媒体屏幕尺寸）, 以满足个别设备网页尺寸不匹配等问题。</li>
<li>screen<br><br>主要适用于彩色的电脑屏幕</li>
<li>speech<br><br>解析speech这个合成器. 注意: CSS2已经有一个相似的媒体类型叫aural.<br><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media</a></li>
</ul>
<h4 id="12-编写高效的-CSS-应该注意什么？"><a href="#12-编写高效的-CSS-应该注意什么？" class="headerlink" title="12.编写高效的 CSS 应该注意什么？"></a>12.编写高效的 CSS 应该注意什么？</h4><p>首先，浏览器从最右边的选择器，即关键选择器（key selector），向左依次匹配。根据关键选择器，浏览器从 DOM 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。选择器匹配语句链越短，浏览器的匹配速度越快。避免使用标签和通用选择器作为关键选择器，因为它们会匹配大量的元素，浏览器必须要进行大量的工作，去判断这些元素的父元素们是否匹配。</p>
<p><a href="https://bem.info/" target="_blank" rel="noopener">BEM (Block Element Modifier)</a> methodology recommends that everything has a single class, and, where you need hierarchy, that gets baked into the name of the class as well, this naturally makes the selector efficient and easy to override.<br><a href="https://bem.info/" target="_blank" rel="noopener">BEM (Block Element Modifier)</a>原则上建议为独立的 CSS 类命名，并且在需要层级关系时，将关系也体现在命名中，这自然会使选择器高效且易于覆盖。</p>
<p>搞清楚哪些 CSS 属性会触发重新布局（reflow）、重绘（repaint）和合成（compositing）。在写样式时，避免触发重新布局的可能。</p>
<ul>
<li><a href="https://developers.google.com/web/fundamentals/performance/rendering/" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/rendering/</a></li>
<li><a href="https://csstriggers.com/" target="_blank" rel="noopener">https://csstriggers.com/</a></li>
</ul>
<h4 id="13-使用-CSS-预处理的优缺点分别是什么？"><a href="#13-使用-CSS-预处理的优缺点分别是什么？" class="headerlink" title="13.使用 CSS 预处理的优缺点分别是什么？"></a>13.使用 CSS 预处理的优缺点分别是什么？</h4><p>优点：</p>
<ul>
<li>提高 CSS 可维护性。</li>
<li>易于编写嵌套选择器。</li>
<li>引入变量，增添主题功能。可以在不同的项目中共享主题文件。</li>
<li>通过混合（Mixins）生成重复的 CSS。</li>
<li>Splitting your code into multiple files. CSS files can be split up too but doing so will require a HTTP request to download each CSS file.</li>
<li>将代码分割成多个文件。不进行预处理的 CSS，虽然也可以分割成多个文件，但需要建立多个 HTTP 请求加载这些文件。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要预处理工具。</li>
<li>重新编译的时间可能会很慢。</li>
</ul>
<h4 id="14-对于你使用过的-CSS-预处理，说说喜欢和不喜欢的地方？"><a href="#14-对于你使用过的-CSS-预处理，说说喜欢和不喜欢的地方？" class="headerlink" title="14.对于你使用过的 CSS 预处理，说说喜欢和不喜欢的地方？"></a>14.对于你使用过的 CSS 预处理，说说喜欢和不喜欢的地方？</h4><p>喜欢：</p>
<ul>
<li>绝大部分优点上题以及提过。</li>
<li>Less 用 JavaScript 实现，与 NodeJS 高度结合。</li>
</ul>
<p>Dislikes:</p>
<ul>
<li>我通过<code>node-sass</code>使用 Sass，它用 C ++ 编写的 LibSass 绑定。在 Node 版本切换时，我必须经常重新编译。</li>
<li>Less 中，变量名称以<code>@</code>作为前缀，容易与 CSS 关键字混淆，如<code>@media</code>、<code>@import</code>和<code>@font-face</code>。</li>
</ul>
<h4 id="15-如何实现一个使用非标准字体的网页设计？"><a href="#15-如何实现一个使用非标准字体的网页设计？" class="headerlink" title="15.如何实现一个使用非标准字体的网页设计？"></a>15.如何实现一个使用非标准字体的网页设计？</h4><p>使用<code>@font-face</code>并为不同的<code>font-weight</code>定义<code>font-family</code>。</p>
<h4 id="16-解释浏览器如何确定哪些元素与-CSS-选择器匹配。"><a href="#16-解释浏览器如何确定哪些元素与-CSS-选择器匹配。" class="headerlink" title="16.解释浏览器如何确定哪些元素与 CSS 选择器匹配。"></a>16.解释浏览器如何确定哪些元素与 CSS 选择器匹配。</h4><p>这部分与上面关于编写高效的 CSS 有关。浏览器从最右边的选择器（关键选择器）根据关键选择器，浏览器从 DOM 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。选择器匹配语句链越短，浏览器的匹配速度越快。</p>
<p>例如，对于形如<code>p span</code>的选择器，浏览器首先找到所有<code>&lt;span&gt;</code>元素，并遍历它的父元素直到根元素以找到<code>&lt;p&gt;</code>元素。对于特定的<code>&lt;span&gt;</code>，只要找到一个<code>&lt;p&gt;</code>，就知道’<span>`已经匹配并停止继续匹配。</span></p>
<ul>
<li><a href="https://stackoverflow.com/questions/5797014/why-do-browsers-match-css-selectors-from-right-to-left" target="_blank" rel="noopener">https://stackoverflow.com/questions/5797014/why-do-browsers-match-css-selectors-from-right-to-left</a></li>
</ul>
<h4 id="17-描述伪元素及其用途。"><a href="#17-描述伪元素及其用途。" class="headerlink" title="17.描述伪元素及其用途。"></a>17.描述伪元素及其用途。</h4><p>CSS 伪元素是添加到选择器的关键字，去选择元素的特定部分。它们可以用于装饰（<code>:first-line</code>，<code>:first-letter</code>）或将元素添加到标记中（与 content:…组合），而不必修改标记（<code>:before</code>，<code>:after</code>）。</p>
<ul>
<li><code>:first-line</code>和<code>:first-letter</code>可以用来修饰文字。</li>
<li>上面提到的<code>.clearfix</code>方法中，使用<code>clear: both</code>来添加不占空间的元素。</li>
<li>使用<code>:before</code>和<code>after</code>展示提示中的三角箭头。鼓励关注点分离，因为三角被视为样式的一部分，而不是真正的 DOM。如果不使用额外的 HTML 元素，只用 CSS 样式绘制三角形是不太可能的。</li>
</ul>
<ul>
<li><a href="https://css-tricks.com/almanac/selectors/a/after-and-before/" target="_blank" rel="noopener">https://css-tricks.com/almanac/selectors/a/after-and-before/</a></li>
</ul>
<h4 id="18-说说你对盒模型的理解，以及如何告知浏览器使用不同的盒模型渲染布局。"><a href="#18-说说你对盒模型的理解，以及如何告知浏览器使用不同的盒模型渲染布局。" class="headerlink" title="18.说说你对盒模型的理解，以及如何告知浏览器使用不同的盒模型渲染布局。"></a>18.说说你对盒模型的理解，以及如何告知浏览器使用不同的盒模型渲染布局。</h4><p>CSS 盒模型描述了以文档树中的元素而生成的矩形框，并根据排版模式进行布局。每个盒子都有一个内容区域（例如文本，图像等）以及周围可选的<code>padding</code>、<code>border</code>和<code>margin</code>区域。</p>
<p>CSS 盒模型负责计算：</p>
<ul>
<li>块级元素占用多少空间。</li>
<li>边框是否重叠，边距是否合并。</li>
<li>盒子的尺寸。</li>
</ul>
<p>盒模型有以下规则：</p>
<ul>
<li>块级元素的大小由<code>width</code>、<code>height</code>、<code>padding</code>、<code>border</code>和<code>margin</code>决定。</li>
<li>如果没有指定<code>height</code>，则块级元素的高度等于其包含子元素的内容高度加上<code>padding</code>（除非有浮动元素，请参阅下文）。</li>
<li>如果没有指定<code>width</code>，则非浮动块级元素的宽度等于其父元素的宽度减去父元素的<code>padding</code>。</li>
<li>元素的<code>height</code>是由内容的<code>height</code>来计算的。</li>
<li>元素的<code>width</code>是由内容的<code>width</code>来计算的。</li>
<li>默认情况下，<code>padding</code>和<code>border</code>不是元素<code>width</code>和<code>height</code>的组成部分。</li>
</ul>
<ul>
<li><a href="https://www.smashingmagazine.com/2010/06/the-principles-of-cross-browser-css-coding/#understand-the-css-box-model" target="_blank" rel="noopener">https://www.smashingmagazine.com/2010/06/the-principles-of-cross-browser-css-coding/#understand-the-css-box-model</a></li>
</ul>
<h4 id="19-box-sizing-border-box-会产生怎样的效果？"><a href="#19-box-sizing-border-box-会产生怎样的效果？" class="headerlink" title="19.{ box-sizing: border-box; }会产生怎样的效果？"></a>19.<code>{ box-sizing: border-box; }</code>会产生怎样的效果？</h4><ul>
<li>元素默认应用了<code>box-sizing: content-box</code>，元素的宽高只会决定内容（content）的大小。</li>
<li><code>box-sizing: border-box</code>改变计算元素<code>width</code>和<code>height</code>的方式，<code>border</code>和<code>padding</code>的大小也将计算在内。</li>
<li>元素的<code>height</code> = 内容（content）的高度 + 垂直方向的<code>padding</code> + 垂直方向<code>border</code>的宽度</li>
<li>元素的<code>width</code> = 内容（content）的宽度 + 水平方向的<code>padding</code> + 水平方向<code>border</code>的宽度</li>
</ul>
<h4 id="20-display的属性值都有哪些？"><a href="#20-display的属性值都有哪些？" class="headerlink" title="20.display的属性值都有哪些？"></a>20.<code>display</code>的属性值都有哪些？</h4><ul>
<li><code>none</code>, <code>block</code>, <code>inline</code>, <code>inline-block</code>, <code>table</code>, <code>table-row</code>, <code>table-cell</code>, <code>list-item</code>.</li>
</ul>
<h4 id="21-inline和inline-block有什么区别？"><a href="#21-inline和inline-block有什么区别？" class="headerlink" title="21.inline和inline-block有什么区别？"></a>21.<code>inline</code>和<code>inline-block</code>有什么区别？</h4><p>我把<code>block</code>也加入其中，为了获得更好的比较。</p>
<table>
<thead>
<tr>
<th></th>
<th><code>block</code></th>
<th><code>inline-block</code></th>
<th><code>inline</code></th>
</tr>
</thead>
<tbody><tr>
<td>大小</td>
<td>填充其父容器的宽度。</td>
<td>取决于内容。</td>
<td>取决于内容。</td>
</tr>
<tr>
<td>定位</td>
<td>从新的一行开始，并且不允许旁边有 HTML 元素（除非是<code>float</code>）</td>
<td>与其他内容一起流动，并允许旁边有其他元素。</td>
<td>与其他内容一起流动，并允许旁边有其他元素。</td>
</tr>
<tr>
<td>能否设置<code>width</code>和<code>height</code></td>
<td>能</td>
<td>能</td>
<td>不能。 设置会被忽略。</td>
</tr>
<tr>
<td>可以使用<code>vertical-align</code>对齐</td>
<td>不可以</td>
<td>可以</td>
<td>可以</td>
</tr>
<tr>
<td>边距（margin）和填充（padding）</td>
<td>各个方向都存在</td>
<td>各个方向都存在</td>
<td>只有水平方向存在。垂直方向会被忽略。 尽管<code>border</code>和<code>padding</code>在<code>content</code>周围，但垂直方向上的空间取决于’line-height’</td>
</tr>
<tr>
<td>浮动（float）</td>
<td>-</td>
<td>-</td>
<td>就像一个<code>block</code>元素，可以设置垂直边距和填充。</td>
</tr>
</tbody></table>
<h4 id="22-relative、fixed、absolute和static四种定位有什么区别？"><a href="#22-relative、fixed、absolute和static四种定位有什么区别？" class="headerlink" title="22.relative、fixed、absolute和static四种定位有什么区别？"></a>22.<code>relative</code>、<code>fixed</code>、<code>absolute</code>和<code>static</code>四种定位有什么区别？</h4><p>经过定位的元素，其<code>position</code>属性值必然是<code>relative</code>、<code>absolute</code>、<code>fixed</code>或<code>sticky</code>。</p>
<ul>
<li><code>static</code>：默认定位属性值。该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。</li>
<li><code>relative</code>：该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。</li>
<li><code>absolute</code>：不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。</li>
<li><code>fixed</code>：不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。</li>
<li><code>sticky</code>：盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 <code>table</code> 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。<code>position: sticky</code> 对 <code>table</code> 元素的效果与 <code>position: relative</code> 相同。</li>
</ul>
<ul>
<li><a href="https://developer.mozilla.org/en/docs/Web/CSS/position" target="_blank" rel="noopener">https://developer.mozilla.org/en/docs/Web/CSS/position</a></li>
</ul>
<h4 id="23-你使用过哪些现有的-CSS-框架？你是如何改进它们的？"><a href="#23-你使用过哪些现有的-CSS-框架？你是如何改进它们的？" class="headerlink" title="23.你使用过哪些现有的 CSS 框架？你是如何改进它们的？"></a>23.你使用过哪些现有的 CSS 框架？你是如何改进它们的？</h4><ul>
<li>Bootstrap： 更新周期缓慢。Bootstrap 4 已经处于 alpha 版本将近两年了。添加了在页面中广泛使用的微调按钮组件。</li>
<li>Semantic UI：源代码结构使得自定义主题很难理解。非常规主题系统的使用体验很差。外部库的路径需要硬编码（hard code）配置。变量重新赋值没有 Bootstrap 设计得好。</li>
<li>Bulma： 需要很多非语义的类和标记，显得很多余。不向后兼容，以至于升级版本后，会破坏应用的正常运行。</li>
<li>jquery UI</li>
<li>MUI</li>
</ul>
<h4 id="24-你了解-CSS-Flex-和-Grid-吗？"><a href="#24-你了解-CSS-Flex-和-Grid-吗？" class="headerlink" title="24.你了解 CSS Flex 和 Grid 吗？"></a>24.你了解 CSS Flex 和 Grid 吗？</h4><p>Flex 主要用于一维布局，而 Grid 则用于二维布局。</p>
<p>Flex：flex容器中存在两条轴， 横轴和纵轴， 容器中的每个单元称为flex item。</p>
<p>在容器上可以设置6个属性：</p>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
<p>注意：当设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。</p>
<p>Flex 有六种属性可运用在 item 项目上:</p>
<ol>
<li><p>order</p>
</li>
<li><p>flex-basis</p>
</li>
<li><p>flex-grow</p>
</li>
<li><p>flex-shrink</p>
</li>
<li><p>flex</p>
</li>
<li><p>align-self</p>
<p>​</p>
</li>
</ol>
<p>Grid：CSS网格布局用于将页面分割成数个主要区域，或者用来定义组件内部元素间大小、位置和图层之间的关系。</p>
<p>像表格一样，网格布局让我们能够按行或列来对齐元素。 但是，使用CSS网格可能还是比CSS表格更容易布局。 例如，网格容器的子元素可以自己定位，以便它们像CSS定位的元素一样，真正的有重叠和层次。</p>
<h4 id="25-响应式设计与自适应设计有何不同？"><a href="#25-响应式设计与自适应设计有何不同？" class="headerlink" title="25.响应式设计与自适应设计有何不同？"></a>25.响应式设计与自适应设计有何不同？</h4><p>响应式设计和自适应设计都以提高不同设备间的用户体验为目标，根据视窗大小、分辨率、使用环境和控制方式等参数进行优化调整。</p>
<p>响应式设计的适应性原则：网站应该凭借一份代码，在各种设备上都有良好的显示和使用效果。响应式网站通过使用媒体查询，自适应栅格和响应式图片，基于多种因素进行变化，创造出优良的用户体验。就像一个球通过膨胀和收缩，来适应不同大小的篮圈。</p>
<p>自适应设计更像是渐进式增强的现代解释。与响应式设计单一地去适配不同，自适应设计通过检测设备和其他特征，从早已定义好的一系列视窗大小和其他特性中，选出最恰当的功能和布局。与使用一个球去穿过各种的篮筐不同，自适应设计允许使用多个球，然后根据不同的篮筐大小，去选择最合适的一个。</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Archive/Apps/Design/UI_layout_basics/Responsive_design_versus_adaptive_design" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Archive/Apps/Design/UI_layout_basics/Responsive_design_versus_adaptive_design</a></li>
<li><a href="http://mediumwell.com/responsive-adaptive-mobile/" target="_blank" rel="noopener">http://mediumwell.com/responsive-adaptive-mobile/</a></li>
<li><a href="https://css-tricks.com/the-difference-between-responsive-and-adaptive-design/" target="_blank" rel="noopener">https://css-tricks.com/the-difference-between-responsive-and-adaptive-design/</a></li>
</ul>
<h4 id="26-你有没有使用过视网膜分辨率的图形？当中使用什么技术？"><a href="#26-你有没有使用过视网膜分辨率的图形？当中使用什么技术？" class="headerlink" title="26.你有没有使用过视网膜分辨率的图形？当中使用什么技术？"></a>26.你有没有使用过视网膜分辨率的图形？当中使用什么技术？</h4><p>我倾向于使用更高分辨率的图形（显示尺寸的两倍）来处理视网膜显示。更好的方法是使用媒体查询，像<code>@media only screen and (min-device-pixel-ratio: 2) { ... }</code>，然后改变<code>background-image</code>。</p>
<p>对于图标类的图形，我会尽可能使用 svg 和图标字体，因为它们在任何分辨率下，都能被渲染得十分清晰。</p>
<p>还有一种方法是，在检查了<code>window.devicePixelRatio</code>的值后，利用 JavaScript 将<code>&lt;img&gt;</code>的<code>src</code>属性修改，用更高分辨率的版本进行替换。</p>
<ul>
<li><a href="https://www.sitepoint.com/css-techniques-for-retina-displays/" target="_blank" rel="noopener">https://www.sitepoint.com/css-techniques-for-retina-displays/</a></li>
</ul>
<h4 id="27-什么情况下，用translate-而不用绝对定位？什么时候，情况相反。"><a href="#27-什么情况下，用translate-而不用绝对定位？什么时候，情况相反。" class="headerlink" title="27.什么情况下，用translate()而不用绝对定位？什么时候，情况相反。"></a>27.什么情况下，用<code>translate()</code>而不用绝对定位？什么时候，情况相反。</h4><p><code>translate()</code>是<code>transform</code>的一个值。改变<code>transform</code>或<code>opacity</code>不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。而改变绝对定位会触发重新布局，进而触发重绘和复合。<code>transform</code>使浏览器为元素创建一个 GPU 图层，但改变绝对定位会使用到 CPU。 因此<code>translate()</code>更高效，可以缩短平滑动画的绘制时间。</p>
<p>当使用<code>translate()</code>时，元素仍然占据其原始空间（有点像<code>position：relative</code>），这与改变绝对定位不同。</p>
<ul>
<li><a href="https://www.paulirish.com/2012/why-moving-elements-with-translate-is-better-than-posabs-topleft/" target="_blank" rel="noopener">https://www.paulirish.com/2012/why-moving-elements-with-translate-is-better-than-posabs-topleft/</a></li>
</ul>
<ul>
<li><a href="https://neal.codes/blog/front-end-interview-css-questions" target="_blank" rel="noopener">https://neal.codes/blog/front-end-interview-css-questions</a></li>
<li><a href="https://quizlet.com/28293152/front-end-interview-questions-css-flash-cards/" target="_blank" rel="noopener">https://quizlet.com/28293152/front-end-interview-questions-css-flash-cards/</a></li>
<li><a href="http://peterdoes.it/2015/12/03/a-personal-exercise-front-end-job-interview-questions-and-my-answers-all/" target="_blank" rel="noopener">http://peterdoes.it/2015/12/03/a-personal-exercise-front-end-job-interview-questions-and-my-answers-all/</a></li>
</ul>
<h4 id="28-行内元素、块级元素区别"><a href="#28-行内元素、块级元素区别" class="headerlink" title="28.行内元素、块级元素区别"></a>28.行内元素、块级元素区别</h4><p>行内元素：和其他元素都在一行上，高度、行高及外边距和内边距都不可改变，文字图片的宽度不可改变，只能容纳文本或者其他行内元素；其中img是行元素</p>
<p>块级元素：总是在新行上开始，高度、行高及外边距和内边距都可控制，可以容纳内敛元素和其他元素；行元素转换为块级元素方式：display：block；</p>
<h4 id="29-水平垂直居中的方式"><a href="#29-水平垂直居中的方式" class="headerlink" title="29.水平垂直居中的方式"></a>29.水平垂直居中的方式</h4><p>flex</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 父容器</span><br><span class="line">display: flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">align-items: center;</span><br></pre></td></tr></table></figure>

<p>position</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 父容器</span><br><span class="line">position: relative;</span><br><span class="line"></span><br><span class="line">// 子容器</span><br><span class="line">position:absolute;</span><br><span class="line">margin:auto;</span><br><span class="line">top:0;</span><br><span class="line">bottom:0;</span><br><span class="line">left:0;</span><br><span class="line">right:0;</span><br></pre></td></tr></table></figure>

<p>position+transform</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 父容器</span><br><span class="line">position: relative;</span><br><span class="line"></span><br><span class="line">// 子容器</span><br><span class="line">position: absolute;</span><br><span class="line">top: 50%;</span><br><span class="line">left: 50%;</span><br><span class="line">transform: translate(-50%, -50%);</span><br></pre></td></tr></table></figure>

<p>table-cell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">html, body &#123;</span><br><span class="line">    height: 100%;</span><br><span class="line">    width: 100%;</span><br><span class="line">    margin: 0;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    display: table;</span><br><span class="line">    height: 100%;</span><br><span class="line">    width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.content &#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.inner &#123;</span><br><span class="line">    background-color: #000;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="30-display-none、visibile-hidden、opacity-0的区别"><a href="#30-display-none、visibile-hidden、opacity-0的区别" class="headerlink" title="30.display:none、visibile:hidden、opacity:0的区别"></a>30.display:none、visibile:hidden、opacity:0的区别</h4><table>
<thead>
<tr>
<th></th>
<th>是否隐藏</th>
<th>是否在文档中占用空间</th>
<th>是否会触发事件</th>
</tr>
</thead>
<tbody><tr>
<td>display: none</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>visibile: hidden</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>opacity: 0</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<h4 id="31-CSS中link和-import的区别"><a href="#31-CSS中link和-import的区别" class="headerlink" title="31.CSS中link和@import的区别"></a>31.CSS中link和@import的区别</h4><ul>
<li>link属于HTML标签，而@import是CSS提供的</li>
<li>页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载</li>
<li>import只在IE5以上才能识别，而link是HTML标签，无兼容问题</li>
<li>link方式的样式的权重 高于@import的权重</li>
</ul>
<p><a href="#css"></a></p>
<h4 id="32-如何用css实现瀑布流布局"><a href="#32-如何用css实现瀑布流布局" class="headerlink" title="32.如何用css实现瀑布流布局"></a>32.如何用css实现瀑布流布局</h4><p>利用column-count和break-inside这两个CSS3属性即可，复制如下代码即可察看效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        body &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        .waterfall-container &#123;</span><br><span class="line">            /分几列/</span><br><span class="line">            column-count: 2;</span><br><span class="line">            width: 100%;</span><br><span class="line">            / 列间距 /</span><br><span class="line">            column-gap: 10px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .waterfall-item &#123;</span><br><span class="line">            break-inside: avoid;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 100px;</span><br><span class="line">            margin-bottom: 10px;</span><br><span class="line">            background: #ddd;</span><br><span class="line">            column-gap: 0;</span><br><span class="line">            text-align: center;</span><br><span class="line">            color: #fff;</span><br><span class="line">            font-size: 40px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;waterfall-container&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 100px&quot;&gt;1&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 300px&quot;&gt;2&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 400px&quot;&gt;3&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 100px&quot;&gt;4&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 300px&quot;&gt;5&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 600px&quot;&gt;6&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 400px&quot;&gt;7&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 300px&quot;&gt;8&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 700px&quot;&gt;9&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 100px&quot;&gt;10&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><a href="#css"></a></p>
<h4 id="33-文本超出部分显示省略号"><a href="#33-文本超出部分显示省略号" class="headerlink" title="33.文本超出部分显示省略号"></a>33.文本超出部分显示省略号</h4><p>单行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">overflow: hidden;</span><br><span class="line">text-overflow:ellipsis;</span><br><span class="line">white-space: nowrap;</span><br></pre></td></tr></table></figure>

<p>多行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display: -webkit-box;</span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line">-webkit-line-clamp: 3; // 最多显示几行</span><br><span class="line">overflow: hidden;</span><br></pre></td></tr></table></figure>

<h4 id="34-利用伪元素画三角"><a href="#34-利用伪元素画三角" class="headerlink" title="34.利用伪元素画三角"></a>34.利用伪元素画三角</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.info-tab &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.info-tab::after &#123;</span><br><span class="line">    content: &apos;&apos;;</span><br><span class="line">    border: 4px solid transparent;</span><br><span class="line">    border-top-color: #2c8ac2;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="32-介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"><a href="#32-介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？" class="headerlink" title="32.介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"></a>32.介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h4><p>（1）有两种， IE 盒子模型、W3C 盒子模型；</p>
<p>（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；</p>
<p>（3）区  别： IE的content部分把 border 和 padding计算了进去;</p>
<h4 id="33-CSS选择符有哪些？哪些属性可以继承？"><a href="#33-CSS选择符有哪些？哪些属性可以继承？" class="headerlink" title="33.CSS选择符有哪些？哪些属性可以继承？"></a>33.CSS选择符有哪些？哪些属性可以继承？</h4><p>1.id选择器（ # myid）</p>
<p>2.类选择器（.myclassname）</p>
<p>3.标签选择器（div, h1, p）</p>
<p>4.相邻选择器（h1 + p）</p>
<p>5.子选择器（ul &gt; li）</p>
<p>6.后代选择器（li a）</p>
<p>7.通配符选择器（  ）</p>
<p>8.属性选择器（a[rel = “external”]）</p>
<p>9.伪类选择器（a:hover, li:nth-child）</p>
<p>可继承的样式： font-sizefont-family color, UL LI DL DD DT;</p>
<p>不可继承的样式：border paddingmargin width height</p>
<h4 id="34-css定义的权重"><a href="#34-css定义的权重" class="headerlink" title="34.css定义的权重"></a>34.css定义的权重</h4><p>   标签的权重为1，class的权重为10，id的权重为100</p>
<h4 id="35-如果需要手动写动画，你认为最小时间间隔是多久，为什么？"><a href="#35-如果需要手动写动画，你认为最小时间间隔是多久，为什么？" class="headerlink" title="35.如果需要手动写动画，你认为最小时间间隔是多久，为什么？"></a>35.如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h4><p>   多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms</p>
<h4 id="36-简单介绍下CSS的盒子模型，他都包含哪些属性？"><a href="#36-简单介绍下CSS的盒子模型，他都包含哪些属性？" class="headerlink" title="36.简单介绍下CSS的盒子模型，他都包含哪些属性？"></a>36.简单介绍下CSS的盒子模型，他都包含哪些属性？</h4><p>  width,height,margin,padding,border</p>
<h4 id="37-宽高都200px的div在浏览器窗口居中（水平垂直都居中）"><a href="#37-宽高都200px的div在浏览器窗口居中（水平垂直都居中）" class="headerlink" title="37.宽高都200px的div在浏览器窗口居中（水平垂直都居中）"></a>37.宽高都200px的div在浏览器窗口居中（水平垂直都居中）</h4><p>  position:fixed;width:200px;height:200px;left:50%;top:50%;</p>
<p>  margin-left:-100px;margin-top:-100px;</p>
<h4 id="39-超链接访问过后hover样式就不出现了-被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序"><a href="#39-超链接访问过后hover样式就不出现了-被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序" class="headerlink" title="39.超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:"></a>39.超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:</h4><p>  L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}</p>
<h4 id="40-低版本浏览器不支持display-inline-block属性，请问怎么兼容"><a href="#40-低版本浏览器不支持display-inline-block属性，请问怎么兼容" class="headerlink" title="40.低版本浏览器不支持display:inline-block属性，请问怎么兼容"></a>40.低版本浏览器不支持display:inline-block属性，请问怎么兼容</h4><p>display:inline;zoom:1;</p>
<h4 id="41-在使用display-inline-block时，inline-block元素会有4px左右的空隙，这是什么原因导致的以及解决方法"><a href="#41-在使用display-inline-block时，inline-block元素会有4px左右的空隙，这是什么原因导致的以及解决方法" class="headerlink" title="41.在使用display:inline-block时，inline-block元素会有4px左右的空隙，这是什么原因导致的以及解决方法"></a>41.在使用display:inline-block时，inline-block元素会有4px左右的空隙，这是什么原因导致的以及解决方法</h4><p>（1） 取消换行和空格</p>
<p>（2） 设置父元素的font-size为0，在给子元素设置自身的字体大小</p>
<h4 id="42-写出下面三个的区别？"><a href="#42-写出下面三个的区别？" class="headerlink" title="42.写出下面三个的区别？"></a>42.写出下面三个的区别？</h4><p>height{}</p>
<p>_height{}</p>
<p>+height{}</p>
<p>\ IE7及以下</p>
<p>_IE6</p>
<p>+IE7</p>
<h4 id="43-Inline-block默认的对其方式是什么？在使用inline-block时在内容不同的时候想要保持内容水平对齐，说一下你采用的方法？"><a href="#43-Inline-block默认的对其方式是什么？在使用inline-block时在内容不同的时候想要保持内容水平对齐，说一下你采用的方法？" class="headerlink" title="43.Inline-block默认的对其方式是什么？在使用inline-block时在内容不同的时候想要保持内容水平对齐，说一下你采用的方法？"></a>43.Inline-block默认的对其方式是什么？在使用inline-block时在内容不同的时候想要保持内容水平对齐，说一下你采用的方法？</h4><p>默认对齐方式：base-line</p>
<p>水平对齐：vertical-align:top;</p>
<h4 id="44-简明说一下CSS-link于-import的区别和用法"><a href="#44-简明说一下CSS-link于-import的区别和用法" class="headerlink" title="44.简明说一下CSS link于@import的区别和用法"></a>44.简明说一下CSS link于@import的区别和用法</h4><p>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</p>
<p>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</p>
<p>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</p>
<p>link支持使用Javascript控制DOM去改变样式；而@import不支持。</p>
<h4 id="45-HTML5、CSS3里面都新增了那些新特性？"><a href="#45-HTML5、CSS3里面都新增了那些新特性？" class="headerlink" title="45.HTML5、CSS3里面都新增了那些新特性？"></a>45.HTML5、CSS3里面都新增了那些新特性？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTML5新增如下：</span><br><span class="line">1. 拖拽释放(Drag and drop) API</span><br><span class="line">2. 语义化更好的内容标签（header,nav,footer,aside,article,section）</span><br><span class="line">3. 音频、视频 API(audio,video)</span><br><span class="line">4. 画布(Canvas) API</span><br><span class="line">5. 地理(Geolocation) API</span><br><span class="line">6. 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；</span><br><span class="line">7. sessionStorage 的数据在浏览器关闭后自动删除</span><br><span class="line">8. 表单控件，calendar、date、time、email、url、search</span><br><span class="line">9. 新的技术 webworker, websocket, Geolocation</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CSS3新增如下：</span><br><span class="line">CSS3的2d，3d变换。transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜</span><br><span class="line">CSS3圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow)，边框图片(border-image)</span><br><span class="line">CSS3动画 Transition,animation</span><br><span class="line">CSS3的媒体查询、多栏布局、伸缩盒子</span><br><span class="line">CSS3新的单位（rem,vw，vh等）</span><br><span class="line">CSS3更多的选择器</span><br></pre></td></tr></table></figure>

<h4 id="46-HTML5-为什么只需要写-lt-DOCTYPEHTML-gt-？"><a href="#46-HTML5-为什么只需要写-lt-DOCTYPEHTML-gt-？" class="headerlink" title="46.HTML5 为什么只需要写 &lt;!DOCTYPEHTML&gt;？"></a>46.HTML5 为什么只需要写 &lt;!DOCTYPEHTML&gt;？</h4><p> HTML5 不基于 SGML（标准通用标记语言），因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；</p>
<p> 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</p>
<h4 id="47-如何处理HTML5新标签的浏览器兼容问题？"><a href="#47-如何处理HTML5新标签的浏览器兼容问题？" class="headerlink" title="47.如何处理HTML5新标签的浏览器兼容问题？"></a>47.如何处理HTML5新标签的浏览器兼容问题？</h4><p>IE8/IE7/IE6支持通过document.createElement方法产生的标签，</p>
<p>可以利用这一特性让这些浏览器支持HTML5新标签，</p>
<p>浏览器支持新标签后，还需要添加标签默认的样式。</p>
<!--[if lt IE 9]>

<script type="text/javascript"src="js/html5shiv.js"></script>

<![endif]-->

<p>将上代码复制到head部分，记住一定要是head部分（因为IE必须在元素解析前知道这个元素，所以这个js文件不能在其他位置调用，否则失效）</p>
<p>最后在css里面加上这段：</p>
<p>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</p>
<p>主要是让这些html5标签成块状，像div那样。</p>
<h4 id="48-cookies，sessionStorage-和-localStorage-的区别？"><a href="#48-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="48.cookies，sessionStorage 和 localStorage 的区别？"></a>48.cookies，sessionStorage 和 localStorage 的区别？</h4><p>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。</p>
<p>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。</p>
<p>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p>
<p>存储大小：</p>
<p>cookie数据大小不能超过4k。</p>
<p>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p>
<p>生命周期：</p>
<p>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</p>
<p>sessionStorage  数据在当前浏览器窗口关闭后自动删除。</p>
<p>cookie         设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p>
<h4 id="49-什么叫优雅降级和渐进增强？"><a href="#49-什么叫优雅降级和渐进增强？" class="headerlink" title="49.什么叫优雅降级和渐进增强？"></a>49.什么叫优雅降级和渐进增强？</h4><p>优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。</p>
<p>如：border-shadow</p>
<p>渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</p>
<p>如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；</p>
<h4 id="50-transition和animation的区别"><a href="#50-transition和animation的区别" class="headerlink" title="50.transition和animation的区别"></a>50.transition和animation的区别</h4><p>transition是过渡，animation是动画。transition只能从一种状态过渡到另外一种状态，animation可以定制复杂动画，可以定义动画的区间等。</p>
<p>transition必须通过一些行为才能触发（js或者伪类来触发），animation的话直接就可以触发。</p>
<h4 id="51-margin-left-calc-100-100px-代码中用到了一个calc（），这个函数的作用是什么？"><a href="#51-margin-left-calc-100-100px-代码中用到了一个calc（），这个函数的作用是什么？" class="headerlink" title="51.margin-left:calc(-100%-100px) 代码中用到了一个calc（），这个函数的作用是什么？"></a>51.margin-left:calc(-100%-100px) 代码中用到了一个calc（），这个函数的作用是什么？</h4><p>答：通过计算来确定CSS属性值。</p>
<p>calc是英文单词calculate(计算)的缩写，是css3的一个新增的功能，你可以使用calc()给元素的border、margin、pading、font-size和width等属性设置动态值。calc()可以使用数学运算中的简单加（+）、减（-）、乘（）和除（/）来解决问题，而且还可以根据单位如px,em,rem和百分比来转化计算</p>
<h4 id="52-简述HTML5新增的canvas、audio、svg标签的作用"><a href="#52-简述HTML5新增的canvas、audio、svg标签的作用" class="headerlink" title="52.简述HTML5新增的canvas、audio、svg标签的作用"></a>52.简述HTML5新增的canvas、audio、svg标签的作用</h4><p>canvas被称作画布，canvas 元素使用 JavaScript 在网页上绘制图像。 画布是一个矩形区域,可以控制其每一像素。</p>
<p>audio标签可以引用音频资源，在页面上播放音乐</p>
<p>svg用XML格式定义图形，可以用来制作矢量图形。</p>
<h4 id="53-简述如何通过CSS进行响应式布局的方式"><a href="#53-简述如何通过CSS进行响应式布局的方式" class="headerlink" title="53.简述如何通过CSS进行响应式布局的方式"></a>53.简述如何通过CSS进行响应式布局的方式</h4><p>响应式布局使用媒体查询@media 定义多个分辨率下的样式，使页面在不同的分辨率下显示不同的样式</p>
<h4 id="54-CSS的单位中，设定元素的长度或宽度与父元素字体大小相关的单位是什么？与html文档元素大小相关的单位是什么？"><a href="#54-CSS的单位中，设定元素的长度或宽度与父元素字体大小相关的单位是什么？与html文档元素大小相关的单位是什么？" class="headerlink" title="54.CSS的单位中，设定元素的长度或宽度与父元素字体大小相关的单位是什么？与html文档元素大小相关的单位是什么？"></a>54.CSS的单位中，设定元素的长度或宽度与父元素字体大小相关的单位是什么？与html文档元素大小相关的单位是什么？</h4><p>em 、rem</p>
<h4 id="55-CSS3实现一段阴影文本持续淡入淡出？"><a href="#55-CSS3实现一段阴影文本持续淡入淡出？" class="headerlink" title="55.CSS3实现一段阴影文本持续淡入淡出？"></a>55.CSS3实现一段阴影文本持续淡入淡出？</h4><p>HTML结构 ：  &lt;divclass=”box”&gt;文本</p>
<p>CSS样式：</p>
<p>​       .box {</p>
<p>​            text-shadow: 1px 1px 2px #F00;</p>
<p>​            -moz-animation:fade1s infinite;</p>
<p>​            -webkit-animation:fade1s infinite;</p>
<p>​            -o-animation:fade1s infinite;</p>
<p>​            animation:fade1s infinite;</p>
<p>​        }</p>
<p>​        @keyframes fade {</p>
<p>​            0%{ opacity: 0;}</p>
<p>​            50%{ opacity: 100;}</p>
<p>​            100%{ opacity: 0;}</p>
<p>​        }</p>
<p>​        @-webkit-keyframes fade {</p>
<p>​            0%{ opacity: 0;}</p>
<p>​            50%{ opacity: 100;}</p>
<p>​            100%{ opacity: 0;}</p>
<p>​        }</p>
<p>​        @-moz-keyframes fade {</p>
<p>​            0%{ opacity: 0;}</p>
<p>​            50%{ opacity: 100;}</p>
<p>​            100%{ opacity: 0;}</p>
<p>​        }</p>
<p>​        @-o-keyframes fade {</p>
<p>​            0%{ opacity: 0;}</p>
<p>​            50%{ opacity: 100;}</p>
<p>​            100%{ opacity: 0;}</p>
<p>​        }</p>
<h4 id="56-简述如何通过CSS进行响应式布局的方式。"><a href="#56-简述如何通过CSS进行响应式布局的方式。" class="headerlink" title="56.简述如何通过CSS进行响应式布局的方式。"></a>56.简述如何通过CSS进行响应式布局的方式。</h4><p>meta标签定义: 使网页适配设备宽度。</p>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">

<p>使用Media Queries适配对应样式</p>
<h4 id="57-如何使用Canvas来画一条简单的线？"><a href="#57-如何使用Canvas来画一条简单的线？" class="headerlink" title="57.如何使用Canvas来画一条简单的线？"></a>57.如何使用Canvas来画一条简单的线？</h4><p>var canvas=document.getElementById(“canvas”);</p>
<p>var cxt=canvas.getContext(‘2d’);</p>
<p>cxt.beginPath();</p>
<p>cxt.lineWidth=10;</p>
<p>cxt.strokeStyle=”#00ff00”;</p>
<p>cxt.moveTo(20,20);</p>
<p>cxt.lineTo(100,20);</p>
<p>cxt.stroke();</p>
<p>cxt.closePath();</p>
<h4 id="58-rgba和opacity的透明效果有什么不同？"><a href="#58-rgba和opacity的透明效果有什么不同？" class="headerlink" title="58.rgba和opacity的透明效果有什么不同？"></a>58.rgba和opacity的透明效果有什么不同？</h4><p>opacity会继承父元素的 opacity 属性，而RGBA设置的元素的后代元素不会继承不透明属性。比如rgba的话,内部的文字透明度不会发生变化，而opacity的话，会影响到内部的文字 </p>
<h4 id="59-FontAwesome和iconfont是什么？他们有什么异同，问什么要使用它，有什么弊端？"><a href="#59-FontAwesome和iconfont是什么？他们有什么异同，问什么要使用它，有什么弊端？" class="headerlink" title="59.FontAwesome和iconfont是什么？他们有什么异同，问什么要使用它，有什么弊端？"></a>59.FontAwesome和iconfont是什么？他们有什么异同，问什么要使用它，有什么弊端？</h4><p>两个都是图标字体。Font Awesome 是一套完美的图标字体,主要目的是和 Bootstrap 搭配使用</p>
<p>Iconfont是阿里的字体库，可以定制自己要的字体图标。</p>
<p>优势：</p>
<p>1、轻量性：一个图标字体比一系列的图像（特别是在Retina屏中使用双倍图像）要小。一旦图标字体加载了，图标就会马上渲染出来，不需要下载一个图像。可以减少HTTP请求，还可以配合HTML5离线存储做性能优化。</p>
<p>2、灵活性：图标字体可以用过font-size属性设置其任何大小，还可以加各种文字效果，包括颜色、Hover状态、透明度、阴影和翻转等效果。可以在任何背景下显示。使用位图的话，必须得为每个不同大小和不同效果的图像输出一个不同文件。</p>
<p>3、兼容性：网页字体支持所有现代浏览器，包括IE低版本。详细兼容性可以点击这里。</p>
<p>弊端：</p>
<p>只能单色</p>
<p>跨域问题</p>
<p>字体图标库似乎体积显得有些过大</p>
<h4 id="60-什么是响应式设计？"><a href="#60-什么是响应式设计？" class="headerlink" title="60.什么是响应式设计？"></a>60.什么是响应式设计？</h4><p>它是关于网站的制作或网页制作的工作。不同的设备有不同的尺寸和不同的功能。响应式设计是让所有的人能在这些设备上让网站运行正常。一部分是媒体查询和不同的视觉效果。一部分是不同的资源（如不同的Javascript来处理触摸与点击自动适应屏幕的对比）。</p>
<h4 id="61-解释下这个CSS选择器什么发生什么？"><a href="#61-解释下这个CSS选择器什么发生什么？" class="headerlink" title="61.解释下这个CSS选择器什么发生什么？"></a>61.解释下这个CSS选择器什么发生什么？</h4><p>[role=navigation] &gt; ul a:not([href^=mailto]) {}</p>
<p>定义了role属性，并且值为navigation的任何元素，其子元素列表下的除邮箱链接之外的所有链接元素。</p>
<p>能够用语言表达清楚这个选择器，证明你理解他们和可以使用他们做一些技术交流。</p>
<h4 id="61-如何处理HTML5新标签的浏览器兼容问题？（自己需要试试）"><a href="#61-如何处理HTML5新标签的浏览器兼容问题？（自己需要试试）" class="headerlink" title="61.如何处理HTML5新标签的浏览器兼容问题？（自己需要试试）"></a>61.如何处理HTML5新标签的浏览器兼容问题？（自己需要试试）</h4><!--[if lt IE 9]>

<script type="text/javascript" src="js/html5shiv.js"></script>

<![endif]-->

<p>将上代码复制到head部分，记住一定要是head部分（因为IE必须在元素解析前知道这个元素，所以这个js文件不能在其他位置调用，否则失效）</p>
<p>最后在css里面加上这段：</p>
<p>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</p>
<p>主要是让这些html5标签成块状，像div那样。</p>
<h4 id="62-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧-？"><a href="#62-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧-？" class="headerlink" title="62.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？"></a>62.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</h4><p>不同浏览器都会带有自己的浏览器默认样式，一般我们需要把这些浏览器默认自带的样式给清楚，一般我们借助reset.css（我们公司里开发前端页面都用这个来清楚浏览器默认样式）</p>
<p>display:inline-block（IE7及以下不支持）</p>
<p>需要对低版本IE特殊处理：{display:inline-block;display:inline;zoom:1;}</p>
<p>display:inline-block 什么时候会显示间隙？怎样消除间隙？</p>
<p>父元素font-size设置成0，子元素重新设置font-size</p>
<p>display:inline-block滥用容易出现布局方面的问题，尤其在左中右、左右等布局方面的问题尤为突出。因此如果是左右布局的话，尽量都用浮动来代替</p>
<p>z-index在IE7及以下版本的话，有时会发现不是谁z-index设置的越高谁就显示在最上面。碰到这种问题需要设置父元素有相对定位属性元素的z-index。先比较父元素的z-index再比较子元素的</p>
<p>IE6双边距</p>
<p>IE6中，元素向左浮动并且设置了左侧的外边距出现了这样的双边距bug。同理，元素向右浮动并且设置右边距也会出现同样的情况。同一行如果有多个浮动元素，第一个浮动元素会出现这个双边距bug，其它的浮动元素则不会。只需要给浮动元素加上display:inline;这样的CSS属性就可以了。</p>
<p>margin-top，margin-bottom的bug</p>
<p>父元素的第一个子元素设置了margin-top,会作用于父元素（值为父元素的margin-top与该margin-top两者中的最大值)，而子元素和父元素的边距则没有发生变化。</p>
<h4 id="63-IE8-IE8及以下-rgba模式不兼容的解决方案"><a href="#63-IE8-IE8及以下-rgba模式不兼容的解决方案" class="headerlink" title="63.IE8-(IE8及以下)rgba模式不兼容的解决方案"></a>63.IE8-(IE8及以下)rgba模式不兼容的解决方案</h4><p>IE8以及以下用滤镜， filter:Alpha(opacity=20);</p>
<h4 id="64-CSS-Hack"><a href="#64-CSS-Hack" class="headerlink" title="64.CSS Hack"></a>64.CSS Hack</h4><p>什么是CSS hack</p>
<p>由于不同厂商的流览器或某浏览器的不同版本（如IE6-IE11,Firefox/Safari/Opera/Chrome等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时，我们为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack!</p>
<p>CSS hack的原理</p>
<p>由于不同的浏览器和浏览器各版本对CSS的支持及解析结果不一样，以及CSS优先级对浏览器展现效果的影响，我们可以据此针对不同的浏览器情景来应用不同的CSS。</p>
<p>CSS hack分类</p>
<p>科普</p>
<p>lte：就是Less than or equal to的简写，也就是小于或等于的意思。</p>
<p>lt ：就是Less than的简写，也就是小于的意思。</p>
<p>gte：就是Greater than or equal to的简写，也就是大于或等于的意思。</p>
<p>gt ：就是Greater than的简写，也就是大于的意思。</p>
<p>! ：就是不等于的意思，跟javascript里的不等于判断符相同</p>
<p>CSS Hack大致有3种表现形式，CSS属性前缀法、选择器前缀法以及IE条件注释法（即HTML头部引用if IE）Hack，实际项目中CSS Hack大部分是针对IE浏览器不同版本之间的表现差异而引入的。</p>
<p>属性前缀法(即类内部Hack)：例如 IE6能识别下划线””和星号”  “，IE7能识别星号”  “，但不能识别下划线””，IE6~IE10都认识”\9”，但firefox前述三个都不能认识.</p>
<p>.all IE{property:value\9;} .gte IE 8{property:value\0;} .lte IE7{property:value;} .IE 8/9{property:value\0;} .IE 9{property:value\9\0;} .IE7{+property:value;} .IE 6{_property:value;} .not IE{property//:value;}</p>
<p>选择器前缀法(即选择器Hack)：例如 IE6能识别html .class{}，IE7能识别+html .class{}或者:first-child+html.class{}。</p>
<p>IE条件注释法(即HTML条件注释Hack)：针对所有IE(注：IE10+已经不再支持条件注释)： <!--[if IE]>IE浏览器显示的内容<![endif]-->，针对IE6及以下版本： <!--[if ltIE 6]>只在IE6-显示的内容<![endif]-->。这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。</p>
<p>只在IE下生效 <!--[if IE]> 这段文字只在IE浏览器显示 <![endif]--></p>
<p>只在IE6下生效 <!--[if IE 6]> 这段文字只在IE6浏览器显示 <![endif]--></p>
<p>只在IE6以上版本生效 &lt;–[if gte IE 6]&gt; 这段文字只在IE6以上(包括)版本IE浏览器显示&lt;![endif]–&gt;</p>
<p>只在IE8上不生效 <!--[if ! IE 8]> 这段文字在非IE8浏览器显示 <![endif]--></p>
<p>非IE浏览器生效 <!--[if !IE]> 这段文字只在非IE浏览器显示 <![endif]--></p>
<h4 id="65-写一个CSS3动画？并让描述transition和animation的区别"><a href="#65-写一个CSS3动画？并让描述transition和animation的区别" class="headerlink" title="65.写一个CSS3动画？并让描述transition和animation的区别"></a>65.写一个CSS3动画？并让描述transition和animation的区别</h4><p>transition是过渡，animation是动画。transition只能从一种状态过渡到另外一种状态，animation可以定制复杂动画，可以定义动画的区间等。</p>
<p>transition必须通过一些行为才能触发（js或者伪类来触发），animation的话不需要直接就可以触发。 </p>
<h4 id="66-BFC-是什么"><a href="#66-BFC-是什么" class="headerlink" title="66.BFC 是什么?"></a>66.BFC 是什么?</h4><p>BFC（块级格式化上下文），一个创建了新的 BFC 的盒子是独立布局的，盒子内元素的布局不会影响盒子外面的元素。在同一个 BFC 中的两个相邻的盒子在垂直方向发生 margin 重叠的问题<br>BFC 是指浏览器中创建了一个独立的渲染区域，该区域内所有元素的布局不会影响到区域外元素的布局，这个渲染区域只对块级元素起作用</p>
<h4 id="67-什么是外边距重叠？重叠的结果是什么？"><a href="#67-什么是外边距重叠？重叠的结果是什么？" class="headerlink" title="67.什么是外边距重叠？重叠的结果是什么？"></a>67.什么是外边距重叠？重叠的结果是什么？</h4><p>答案：<br>外边距重叠就是 margin-collapse。<br>在 CSS 当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。<br>折叠结果遵循下列计算规则：</p>
<ol>
<li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</li>
<li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</li>
<li>两个外边距一正一负时，折叠结果是两者的相加的和。</li>
</ol>
<h4 id="68-你如何对网站的文件和资源进行优化？"><a href="#68-你如何对网站的文件和资源进行优化？" class="headerlink" title="68.你如何对网站的文件和资源进行优化？"></a>68.你如何对网站的文件和资源进行优化？</h4><p>文件合并<br>文件最小化/文件压缩<br>使用 CDN 托管<br>缓存的使用</p>
<h4 id="69-为什么利用多个域名来存储网站资源会更有效？"><a href="#69-为什么利用多个域名来存储网站资源会更有效？" class="headerlink" title="69.为什么利用多个域名来存储网站资源会更有效？"></a>69.为什么利用多个域名来存储网站资源会更有效？</h4><p>CDN 缓存更方便<br>突破浏览器并发限制<br>节约 cookie 带宽<br>节约主域名的连接数，优化页面响应速度<br>防止不必要的安全问题</p>
<h4 id="70-知道-css-有个-content-属性吗？有什么作用？有什么应用？"><a href="#70-知道-css-有个-content-属性吗？有什么作用？有什么应用？" class="headerlink" title="70.知道 css 有个 content 属性吗？有什么作用？有什么应用？"></a>70.知道 css 有个 content 属性吗？有什么作用？有什么应用？</h4><p>知道。css 的 content 属性专门应用在 before/after 伪元素上，用来插入生成内容。<br>最常见的应用是利用伪类清除浮动。</p>
<h4 id="71-HTML5-引入什么新的表单属性？"><a href="#71-HTML5-引入什么新的表单属性？" class="headerlink" title="71.HTML5 引入什么新的表单属性？"></a>71.HTML5 引入什么新的表单属性？</h4><p>Datalist datetime output keygen date month week time number range email url</p>
<h4 id="72-语义化的理解？"><a href="#72-语义化的理解？" class="headerlink" title="72.语义化的理解？"></a>72.语义化的理解？</h4><p>用正确的标签做正确的事情！<br>html 语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；<br>在没有样式 CCS 情况下也以一种文档格式显示，并且是容易阅读的。<br>搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。<br>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p>
<h4 id="73-简述一下-Sass、Less，且说明区别？"><a href="#73-简述一下-Sass、Less，且说明区别？" class="headerlink" title="73.简述一下 Sass、Less，且说明区别？"></a>73.简述一下 Sass、Less，且说明区别？</h4><p>他们是动态的样式语言，是 CSS 预处理器,CSS 上的一种抽象层。他们是一种特殊的语法/语<br>言而编译成 CSS。<br>变量符不一样，less 是@，而 Sass 是$;<br>Sass 支持条件语句，可以使用 if{}else{},for{}循环等等。而 Less 不支持;<br>Sass 是基于 Ruby 的，是在服务端处理的，而 Less 是需要引入 less.js 来处理 Less 代码输<br>出 Css 到浏览器</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/06/10/JavaSciprt/">
                Untitled
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-06-10</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h4 id="1-同源策略"><a href="#1-同源策略" class="headerlink" title="1.同源策略"></a>1.同源策略</h4><p>同源策略可防止 JavaScript 发起跨域请求。源被定义为 URI、主机名和端口号的组合。此策略可防止页面上的恶意脚本通过该页面的文档对象模型，访问另一个网页上的敏感数据。</p>
<h4 id="2-跨域"><a href="#2-跨域" class="headerlink" title="2.跨域"></a>2.跨域</h4><ul>
<li>原因 <br><br>浏览器的同源策略导致了跨域</li>
<li>作用 <br><br>用于隔离潜在恶意文件的重要安全机制</li>
<li>解决</li>
</ul>
<ol>
<li>jsonp ，允许 script 加载第三方资源</li>
<li>反向代理（nginx 服务内部配置 Access-Control-Allow-Origin ）</li>
<li>cors 前后端协作设置请求头部，Access-Control-Allow-Origin 等头部信息</li>
<li>iframe 嵌套通讯，postmessage</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/41479807" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41479807</a> <br><br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 阮一峰</a></p>
<h4 id="3-JSONP"><a href="#3-JSONP" class="headerlink" title="3.JSONP"></a>3.JSONP</h4><p>Jsonp 并不是一种数据格式，而 json 是一种数据格式，jsonp 是用来解决跨域获取数据的一种解决方案，具体是通过动态创建 script 标签，然后通过标签的 src 属性获取 js 文件中的 js 脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是 ajax 技术</p>
<p>这是我认为写得比较通俗易懂的一篇文章 直接转载过来<br><br><a href="https://blog.csdn.net/hansexploration/article/details/80314948" target="_blank" rel="noopener">https://blog.csdn.net/hansexploration/article/details/80314948</a></p>
<h4 id="4-事件绑定的方式"><a href="#4-事件绑定的方式" class="headerlink" title="4.事件绑定的方式"></a>4.事件绑定的方式</h4><ul>
<li><p>嵌入dom</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;func()&quot;&gt;按钮&lt;/button&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = function()&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(&apos;click&apos;,function()&#123;&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-事件委托"><a href="#5-事件委托" class="headerlink" title="5.事件委托"></a>5.事件委托</h4><p>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术，<br>使用事件委托可以节省内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;苹果&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;香蕉&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;凤梨&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">document.querySelector(&apos;ul&apos;).onclick = (event) =&gt; &#123;</span><br><span class="line">  let target = event.target</span><br><span class="line">  if (target.nodeName === &apos;LI&apos;) &#123;</span><br><span class="line">    console.log(target.innerHTML)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">document.querySelectorAll(&apos;li&apos;).forEach((e) =&gt; &#123;</span><br><span class="line">  e.onclick = function() &#123;</span><br><span class="line">    console.log(this.innerHTML)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="6-事件循环"><a href="#6-事件循环" class="headerlink" title="6.事件循环"></a>6.事件循环</h4><p>事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行。</p>
<h4 id="7-事件模型"><a href="#7-事件模型" class="headerlink" title="7.事件模型"></a>7.事件模型</h4><ul>
<li><p>DOM0<br><br>直接绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input onclick=&quot;sayHi()&quot;/&gt;</span><br><span class="line"></span><br><span class="line">btn.onclick = function() &#123;&#125;</span><br><span class="line">btn.onclick = null</span><br></pre></td></tr></table></figure>
</li>
<li><p>DOM2<br><br>DOM2级事件可以冒泡和捕获<br>通过addEventListener绑定<br>通过removeEventListener解绑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 绑定</span><br><span class="line">btn.addEventListener(&apos;click&apos;, sayHi)</span><br><span class="line">// 解绑</span><br><span class="line">btn.removeEventListener(&apos;click&apos;, sayHi)</span><br></pre></td></tr></table></figure>
</li>
<li><p>DOM3<br><br>DOM3具有更多事件类型<br>DOM3级事件在DOM2级事件的基础上添加了更多的事件类型，全部类型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UI事件，当用户与页面上的元素交互时触发，如：load、scroll</span><br><span class="line">焦点事件，当元素获得或失去焦点时触发，如：blur、focus</span><br><span class="line">鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup</span><br><span class="line">滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</span><br><span class="line">文本事件，当在文档中输入文本时触发，如：textInput</span><br><span class="line">键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</span><br><span class="line">合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart</span><br><span class="line">变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><a href="https://www.jianshu.com/p/3acdf5f71d5b" target="_blank" rel="noopener">https://www.jianshu.com/p/3acdf5f71d5b</a></p>
<h4 id="8-target和currentTarget区别"><a href="#8-target和currentTarget区别" class="headerlink" title="8.target和currentTarget区别"></a>8.target和currentTarget区别</h4><ul>
<li>event.target<br><br>返回触发事件的元素</li>
<li>event.currentTarget<br><br>返回绑定事件的元素</li>
</ul>
<h4 id="9-prototype和proto的关系是什么"><a href="#9-prototype和proto的关系是什么" class="headerlink" title="9.prototype和proto的关系是什么"></a>9.prototype和<strong>proto</strong>的关系是什么</h4><p>所有的对象都拥有<strong>proto</strong>属性，它指向Object.prototype（Object是一个原生函数，所有的对象都是Object的实例）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;</span><br><span class="line">obj.__proto__ === Object.prototype // true</span><br></pre></td></tr></table></figure>

<p>所有的函数都同时拥有<strong>proto</strong>和protytpe属性<br>函数的<strong>proto</strong>指向自己的函数实现 函数的protytpe是一个对象 所以函数的prototype也有<strong>proto</strong>属性 指向Object.prototype</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function func() &#123;&#125;</span><br><span class="line">func.prototype.__proto__ === Object.prototype // true</span><br></pre></td></tr></table></figure>

<p>Object.prototype.<strong>proto</strong>指向null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.__proto__ // null</span><br></pre></td></tr></table></figure>

<h4 id="10-什么是Ajax-ajax常用属性和方法"><a href="#10-什么是Ajax-ajax常用属性和方法" class="headerlink" title="10.什么是Ajax,ajax常用属性和方法"></a>10.什么是Ajax,ajax常用属性和方法</h4><p>Ajax(asynchronous JavaScript and XML)是使用客户端上的许多 Web 技术，创建异步 Web 应用的一种 Web 开发技术。借助 Ajax，Web 应用可以异步（在后台）向服务器发送数据和从服务器检索数据，而不会干扰现有页面的显示和行为。通过将数据交换层与表示层分离，Ajax 允许网页和扩展 Web 应用程序动态更改内容，而无需重新加载整个页面。实际上，现在通常将 JSON 替换为 XML，因为 JavaScript 对 JSON 有原生支持优势。<br><br>XMLHttpRequest API 经常用于异步通信。此外还有最近流行的fetch API。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let xmlhttp</span><br><span class="line">if (window.XMLHttpRequest) &#123;</span><br><span class="line">	//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span><br><span class="line">	xmlhttp = new XMLHttpRequest()</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	// IE6, IE5 浏览器执行代码</span><br><span class="line">	xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.onreadystatechange = () =&gt; &#123;</span><br><span class="line">	if (xmlhttp.readyState === 4 &amp;&amp; xmlhttp.status === 200) &#123;</span><br><span class="line">		document.getElementById(&quot;myDiv&quot;).innerHTML = xmlhttp.responseText</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.open(&quot;GET&quot;, &quot;/ajax/test.txt&quot;, true)</span><br><span class="line">xmlhttp.send()</span><br></pre></td></tr></table></figure>

<h4 id="11-Ajax和Fetch区别"><a href="#11-Ajax和Fetch区别" class="headerlink" title="11.Ajax和Fetch区别"></a>11.Ajax和Fetch区别</h4><ul>
<li>ajax是使用XMLHttpRequest对象发起的，但是用起来很麻烦，所以ES6新规范就有了fetch，fetch发一个请求不用像ajax那样写一大堆代码。</li>
<li>使用fetch无法取消一个请求，这是因为fetch基于Promise，而Promise无法做到这一点。</li>
<li>在默认情况下，fetch不会接受或者发送cookies</li>
<li>fetch没有办法原生监测请求的进度，而XMLHttpRequest可以</li>
<li>fetch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理</li>
<li>fetch由于是ES6规范，兼容性上比不上XMLHttpRequest</li>
</ul>
<h4 id="12-ajax-的缺点"><a href="#12-ajax-的缺点" class="headerlink" title="12.ajax 的缺点"></a>12.ajax 的缺点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、ajax 不支持浏览器 back 按钮。</span><br><span class="line">2、安全问题 AJAX 暴露了与服务器交互的细节。</span><br><span class="line">3、对搜索引擎的支持比较弱。</span><br><span class="line">4、破坏了程序的异常机制。</span><br><span class="line">5、ajax跨域访问的问题</span><br></pre></td></tr></table></figure>

<h4 id="13-变量提升"><a href="#13-变量提升" class="headerlink" title="13.变量提升"></a>13.变量提升</h4><p>var会使变量提升，这意味着变量可以在声明之前使用。let和const不会使变量提升，提前使用会报错。<br>变量提升（hoisting）是用于解释代码中变量声明行为的术语。使用var关键字声明或初始化的变量，会将声明语句“提升”到当前作用域的顶部。 但是，只有声明才会触发提升，赋值语句（如果有的话）将保持原样。函数提升在变量提升之前</p>
<h4 id="13-当你在浏览器输入一个地址后发生了什么"><a href="#13-当你在浏览器输入一个地址后发生了什么" class="headerlink" title="13.当你在浏览器输入一个地址后发生了什么"></a>13.当你在浏览器输入一个地址后发生了什么</h4><p>参照php课件图</p>
<h4 id="14-cookie、localStorage、sessionStorage区别"><a href="#14-cookie、localStorage、sessionStorage区别" class="headerlink" title="14.cookie、localStorage、sessionStorage区别"></a>14.cookie、localStorage、sessionStorage区别</h4><table>
<thead>
<tr>
<th>特性</th>
<th>cookie</th>
<th>localStorage</th>
<th>sessionStorage</th>
</tr>
</thead>
<tbody><tr>
<td>数据的生命周期</td>
<td>一般由服务器生成，可设置失效时间，如果在浏览器生成，默认是关闭浏览器之后失效</td>
<td>永久保存，可清除</td>
<td>仅在当前会话有效，关闭页面后清除</td>
</tr>
<tr>
<td>存放数据大小</td>
<td>4KB</td>
<td>5MB</td>
<td>5MB</td>
</tr>
<tr>
<td>与服务器通信</td>
<td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>
<td>仅在客户端保存</td>
<td>仅在客户端保存</td>
</tr>
<tr>
<td>用途</td>
<td>一般由服务器生成，用于标识用户身份</td>
<td>用于浏览器缓存数据</td>
<td>用于浏览器缓存数据</td>
</tr>
</tbody></table>
<h4 id="15-自执行函数-用于什么场景？好处"><a href="#15-自执行函数-用于什么场景？好处" class="headerlink" title="15.自执行函数?用于什么场景？好处?"></a>15.自执行函数?用于什么场景？好处?</h4><p>自执行函数:1、声明一个匿名函数2、马上调用这个匿名函数。<br><br>作用：创建一个独立的作用域。<br></p>
<p>好处：防止变量弥散到全局，以免各种js库冲突。隔离作用域避免污染，或者截断作用域链，避免闭包造成引用变量无法释放。利用立即执行特性，返回需要的业务函数或对象，避免每次通过条件判断来处理<br></p>
<p>场景：一般用于框架、插件等场景</p>
<h4 id="16-实现add函数-让add-a-b-和add-a-b-两种调用结果相同"><a href="#16-实现add函数-让add-a-b-和add-a-b-两种调用结果相同" class="headerlink" title="16.实现add函数,让add(a)(b)和add(a,b)两种调用结果相同"></a>16.实现add函数,让add(a)(b)和add(a,b)两种调用结果相同</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">    if (b === undefined) &#123;</span><br><span class="line">        return function(x) &#123;</span><br><span class="line">            return a + x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id><a href="#" class="headerlink" title></a><a href="#JavaScript"></a></h4><h4 id="17-js中万物皆对象你认为对么"><a href="#17-js中万物皆对象你认为对么" class="headerlink" title="17.js中万物皆对象你认为对么"></a>17.js中万物皆对象你认为对么</h4><p>我认为是对的<br>在JS中有原生函数、基本数据类型，它们的原型最终还是对象。<br>可以看看本文的原生函数</p>
<h4 id="-1"><a href="#-1" class="headerlink" title></a><a href="#JavaScript"></a></h4><h4 id="18-多个页面之间如何进行通信"><a href="#18-多个页面之间如何进行通信" class="headerlink" title="18.多个页面之间如何进行通信"></a>18.多个页面之间如何进行通信</h4><p>有如下几个方式：</p>
<ul>
<li>cookie</li>
<li>web worker</li>
<li>localeStorage和sessionStorage</li>
</ul>
<h4 id="19-css动画和js动画的差异"><a href="#19-css动画和js动画的差异" class="headerlink" title="19.css动画和js动画的差异"></a>19.css动画和js动画的差异</h4><ol>
<li>代码复杂度，js 动画代码相对复杂一些</li>
<li>动画运行时，对动画的控制程度上，js 能够让动画，暂停，取消，终止，css动画不能添加事件</li>
<li>动画性能看，js 动画多了一个js 解析的过程，性能不如 css 动画好</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/41479807" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41479807</a></p>
<h4 id="-2"><a href="#-2" class="headerlink" title></a><a href="#JavaScript"></a></h4><h4 id="20-请用js去除字符串空格"><a href="#20-请用js去除字符串空格" class="headerlink" title="20.请用js去除字符串空格"></a>20.请用js去除字符串空格</h4><p>去除所有空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.replace(/\s/g, &apos;&apos;)</span><br></pre></td></tr></table></figure>

<p>去除两边空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str.replace(/^\s+|\s+$/g, &apos;&apos;)</span><br><span class="line">// 原生方法</span><br><span class="line">str.trim()</span><br></pre></td></tr></table></figure>

<h4 id="21-清除浮动的几种方式"><a href="#21-清除浮动的几种方式" class="headerlink" title="21.清除浮动的几种方式"></a>21.清除浮动的几种方式</h4><ul>
<li>对父级设置适合CSS高度</li>
<li>父级div定义 overflow:hidden</li>
<li>clear:both清除浮动</li>
<li>微元素清楚浮动</li>
</ul>
<h4 id="22-new一个对象经历了什么"><a href="#22-new一个对象经历了什么" class="headerlink" title="22.new一个对象经历了什么"></a>22.new一个对象经历了什么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Test()&#123;&#125;</span><br><span class="line">const test = new Test()</span><br></pre></td></tr></table></figure>

<ol>
<li><p>创建一个新对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置新对象的constructor属性为构造函数的名称，设置新对象的<strong>proto</strong>属性指向构造函数的prototype对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.constructor = Test</span><br><span class="line">obj.__proto__ = Test.prototype</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用新对象调用函数，函数中的this被指向新实例对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test.call(obj)</span><br></pre></td></tr></table></figure>
</li>
<li><p>将初始化完毕的新对象地址，保存到等号左边的变量中</p>
</li>
</ol>
<h4 id="23-如何实现文件断点续传"><a href="#23-如何实现文件断点续传" class="headerlink" title="23.如何实现文件断点续传"></a>23.如何实现文件断点续传</h4><p>断点续传最核心的内容就是把文件“切片”然后再一片一片的传给服务器，但是这看似简单的上传过程却有着无数的坑。</p>
<p>首先是文件的识别，一个文件被分成了若干份之后如何告诉服务器你切了多少块，以及最终服务器应该如何把你上传上去的文件进行合并，这都是要考虑的。</p>
<p>因此在文件开始上传之前，我们和服务器要有一个“握手”的过程，告诉服务器文件信息，然后和服务器约定切片的大小，当和服务器达成共识之后就可以开始后续的文件传输了。</p>
<p>前台要把每一块的文件传给后台，成功之后前端和后端都要标识一下，以便后续的断点。</p>
<p>当文件传输中断之后用户再次选择文件就可以通过标识来判断文件是否已经上传了一部分，如果是的话，那么我们可以接着上次的进度继续传文件，以达到续传的功能。<br>有了HTML5 的 File api之后切割文件比想想的要简单的多的多。</p>
<p>只要用slice 方法就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var packet = file.slice(start, end);</span><br></pre></td></tr></table></figure>

<p>参数start是开始切片的位置，end是切片结束的位置 单位都是字节。通过控制start和end 就可以是实现文件的分块</p>
<p>如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file.slice(0,1000);</span><br><span class="line">file.slice(1000,2000);</span><br><span class="line">file.slice(2000,3000);</span><br><span class="line">// ......</span><br></pre></td></tr></table></figure>

<p>在把文件切成片之后，接下来要做的事情就是把这些碎片传到服务器上。<br>如果中间掉线了，下次再传的时候就得先从服务器获取上一次上传文件的位置，然后以这个位置开始上传接下来的文件内容。</p>
<p><a href="https://www.cnblogs.com/zhwl/p/3580776.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhwl/p/3580776.html</a></p>
<h4 id="24-bind、call、apply的区别"><a href="#24-bind、call、apply的区别" class="headerlink" title="24.bind、call、apply的区别"></a>24.bind、call、apply的区别</h4><p>call和apply其实是一样的，区别就在于传参时参数是一个一个传或者是以一个数组的方式来传。<br><br>call和apply都是在调用时生效，改变调用者的this指向。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let name = &apos;Jack&apos;</span><br><span class="line">const obj = &#123;name: &apos;Tom&apos;&#125;</span><br><span class="line">function sayHi() &#123;console.log(&apos;Hi! &apos; + this.name)&#125;</span><br><span class="line"></span><br><span class="line">sayHi() // Hi! Jack</span><br><span class="line">sayHi.call(obj) // Hi! Tom</span><br></pre></td></tr></table></figure>

<p>bind也是改变this指向，不过不是在调用时生效，而是返回一个新函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const newFunc = sayHi.bind(obj)</span><br><span class="line">newFunc() // Hi! Tom</span><br></pre></td></tr></table></figure>

<h4 id="25-JS的数据类型有哪些？typeof运算符的执行结果都有哪些数据类型？"><a href="#25-JS的数据类型有哪些？typeof运算符的执行结果都有哪些数据类型？" class="headerlink" title="25.JS的数据类型有哪些？typeof运算符的执行结果都有哪些数据类型？"></a>25.JS的数据类型有哪些？typeof运算符的执行结果都有哪些数据类型？</h4><p>数据类型主要包括两部分：</p>
<p>基本数据类型： Undefined、Null、Boolean、Number和String</p>
<p>引用数据类型： Array 、Object</p>
<p>typeof运算符的结果类型：</p>
<p>number,string，boolean,object,function,undefined</p>
<h4 id="26-null，undefined-的区别"><a href="#26-null，undefined-的区别" class="headerlink" title="26.null，undefined 的区别?"></a>26.null，undefined 的区别?</h4><p>null        表示一个对象被定义了，值为“空值”；</p>
<p>undefined   表示不存在这个值。</p>
<h4 id="27-怎么判断一个变量没有被定义"><a href="#27-怎么判断一个变量没有被定义" class="headerlink" title="27.怎么判断一个变量没有被定义"></a>27.怎么判断一个变量没有被定义</h4><p>typeof bianliang ==”undefined”</p>
<h4 id="28-怎么判断一个变量arr的话是否为数组（此题用typeof不行）"><a href="#28-怎么判断一个变量arr的话是否为数组（此题用typeof不行）" class="headerlink" title="28.怎么判断一个变量arr的话是否为数组（此题用typeof不行）"></a>28.怎么判断一个变量arr的话是否为数组（此题用typeof不行）</h4><p>Arr instanceof Array</p>
<h4 id="29-描述下JSON对象的两个很重要的方法"><a href="#29-描述下JSON对象的两个很重要的方法" class="headerlink" title="29.描述下JSON对象的两个很重要的方法"></a>29.描述下JSON对象的两个很重要的方法</h4><p>JSON.parse() //JSON字符串转换为JSON对象</p>
<p>JSON.stringify() //JSON对象转化为字符串</p>
<h4 id="30-“-”、“-”的区别？"><a href="#30-“-”、“-”的区别？" class="headerlink" title="30.“ ===”、“ ==”的区别？"></a>30.“ ===”、“ ==”的区别？</h4><p>==，当且仅当两个运算数相等时，它返回 true，即不检查数据类型</p>
<p>===，只有在无需类型转换运算数就相等的情况下，才返回 true，需要检查数据类型</p>
<h4 id="31-原型、原型链？"><a href="#31-原型、原型链？" class="headerlink" title="31.原型、原型链？"></a>31.原型、原型链？</h4><p>每个由构造函数new出来的实例化对象都自带一个_proto_属性，该属性指向创建它的构造函数的prototype对象。而prototype对象因为是实例，也有自己的_proto_属性，指向它的原型对象。当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，</p>
<p>于是就这样一直找下去，也就是我们平时所说的原型链的概念。</p>
<p>关系：instance.constructor.prototype= instance.<strong>proto</strong></p>
<h4 id="32-eval是做什么的？"><a href="#32-eval是做什么的？" class="headerlink" title="32.eval是做什么的？"></a>32.eval是做什么的？</h4><p>它的功能是把对应的字符串解析成JS代码并运行；</p>
<p>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。</p>
<p>由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’);</p>
<h4 id="33-简单jQuery：请写出代码，ul标签下面有1000个li，写一个性能最高的方式实现，在点击li后，输出li的内容"><a href="#33-简单jQuery：请写出代码，ul标签下面有1000个li，写一个性能最高的方式实现，在点击li后，输出li的内容" class="headerlink" title="33.简单jQuery：请写出代码，ul标签下面有1000个li，写一个性能最高的方式实现，在点击li后，输出li的内容"></a>33.简单jQuery：请写出代码，ul标签下面有1000个li，写一个性能最高的方式实现，在点击li后，输出li的内容</h4><p>$(“ul”).on(“click”,”li”,function(){</p>
<p>$(this).html(“hit”);</p>
<p>})</p>
<h4 id="34-简述下为何通过ajax发送的请求会出现乱码问题，如何解决？"><a href="#34-简述下为何通过ajax发送的请求会出现乱码问题，如何解决？" class="headerlink" title="34.简述下为何通过ajax发送的请求会出现乱码问题，如何解决？"></a>34.简述下为何通过ajax发送的请求会出现乱码问题，如何解决？</h4><p>乱码的问题就是编码格式冲突，我们需要传输中文数据前面加一个encodeURI()编码，例如：encodeURI(j$(“#fk_info”).val())；在接受参数的页面对传过来的编码过后的内容用后端语言进行解码</p>
<h4 id="35-简述DOM，HTML-DOM的区别和联系"><a href="#35-简述DOM，HTML-DOM的区别和联系" class="headerlink" title="35.简述DOM，HTML DOM的区别和联系"></a>35.简述DOM，HTML DOM的区别和联系</h4><p>DOM分为三部分：</p>
<p>（1）核心DOM：遍历DOM树、添加新节点、删除节点、修改节点</p>
<p>（2）HTML DOM：以一种简便的方法访问DOM树</p>
<p>（3）XML DOM：准用于操作XML文档</p>
<p>核心DOM与HTML DOM的区别：</p>
<p>核心DOM ：</p>
<p>对象：Document,Node,  ElementNode,TextNode,AttributeNode，CommentNode,NodeList</p>
<p>核心DOM提供了统一的操作接口，如：createElement、appendChild、setAttribute等</p>
<p>核心DOM创建新元素：var newNode=document.createElement(“img”)</p>
<p>给元素添加属性：e.setAttribure()、e.setAttribureNode()</p>
<p>适用场合：核心DOM适合操作节点，如创建，删除，查找等</p>
<p>HTML DOM：</p>
<p>对象：image,Table,Form,Input,Select等等HTML标签对象化</p>
<p>HTML DOM提供了封装好的各种对象，如：Select、Option等等</p>
<p>适用场合：HTML DOM适合操作属性，如读取或修改属性的值</p>
<h4 id="36-什么是事件流"><a href="#36-什么是事件流" class="headerlink" title="36.什么是事件流"></a>36.什么是事件流</h4><p>DOM(文档对象模型)结构是一个树型结构，当一个HTML元素产生一个事件时，该事件会在元素结点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。DOM同时支持两种事件模型：捕获型事件和冒泡型事件</p>
<h4 id="37-JavaScript原型继承是如何运作的？"><a href="#37-JavaScript原型继承是如何运作的？" class="headerlink" title="37.JavaScript原型继承是如何运作的？"></a>37.JavaScript原型继承是如何运作的？</h4><p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去(知道找到null为止)，也就是我们平时所说的原型链的概念。</p>
<h4 id="38-DOM元素Attribute与Property的区别是什么？"><a href="#38-DOM元素Attribute与Property的区别是什么？" class="headerlink" title="38.DOM元素Attribute与Property的区别是什么？"></a>38.DOM元素Attribute与Property的区别是什么？</h4><p>1、 property是DOM中的属性，是JavaScript里的对象；而attribute是HTML标签上的特性，它的值只能够是字符串；</p>
<p>2、DOM对象初始化时会在创建默认的基本property；只有在HTML标签中定义的attribute才会被保存在property的attributes属性中；</p>
<p>3、attribute会初始化property中的同名属性，但自定义的attribute不会出现在property中；</p>
<p>4、propety是对象，而attribute的值都是字符串；</p>
<p>5、最关键的两句话：</p>
<p>attribute（特性），是我们赋予某个事物的特质或对象。</p>
<p>property（属性），是早已存在的不需要外界赋予的特质。</p>
<h4 id="39-Long-Polling、WebSocket、SSE-Server-Sent-Events-之间有什么差异？请写出WebSocket在浏览器端如何发送及接收消息的相关代码实现（需要考虑传输一场并根据返回数据的格式做不同处理）"><a href="#39-Long-Polling、WebSocket、SSE-Server-Sent-Events-之间有什么差异？请写出WebSocket在浏览器端如何发送及接收消息的相关代码实现（需要考虑传输一场并根据返回数据的格式做不同处理）" class="headerlink" title="39.Long-Polling、WebSocket、SSE(Server-Sent Events)之间有什么差异？请写出WebSocket在浏览器端如何发送及接收消息的相关代码实现（需要考虑传输一场并根据返回数据的格式做不同处理）"></a>39.Long-Polling、WebSocket、SSE(Server-Sent Events)之间有什么差异？请写出WebSocket在浏览器端如何发送及接收消息的相关代码实现（需要考虑传输一场并根据返回数据的格式做不同处理）</h4><p>Long-Polling 自己主动请求数据来获知文件知否发生变化  缺点：会有很多无效请求</p>
<p>SSE 服务器端通知客户端数据变化 服务器端客户端保持一个长连接 缺点：保持长连接需要占用大量的服务器端只要</p>
<p>WebSocket 实时通信 缺点：浏览器支持情况没有上面两种方法好 </p>
<h4 id="40-指出下面代码的区别"><a href="#40-指出下面代码的区别" class="headerlink" title="40.指出下面代码的区别"></a>40.指出下面代码的区别</h4><p>function Order(){</p>
<p>}</p>
<p>var order = Order();  （1）</p>
<p>var order = new Order();（2）</p>
<p>代码（1）是将函数Order()作为一个普通函数去调用的，代码（2）是将Order()作为一个构造函数去调用的；当函数Order的方法体中有this关键之的时候，作为普通函数this指的是window对象，作为构造函数存在的时候this指代的是本对象</p>
<h4 id="41-document-ready-是个什么函数？为什么要用它。"><a href="#41-document-ready-是个什么函数？为什么要用它。" class="headerlink" title="41.$(document).ready()是个什么函数？为什么要用它。"></a>41.$(document).ready()是个什么函数？为什么要用它。</h4><p>问题一： $(document).ready()这个函数是用来取代页面中的window.onload; 不同的是onload()的方法是在页面加载完成后才发生，这包括DOM元素和其他页面元素（例如图片）的加载，因此，使用document.ready()方法的执行速度比onload()的方法要快。</p>
<p>问题二：Javascript 只有在DOM元素已经定义以后才可以对其执行某种操作，jQuery使用document.ready来保证所要执行的代码是在DOM元素被加载完成的情况下执行。 </p>
<h4 id="43-请写一个正则，匹配输入的字符：第一个必须是字母或下划线开头，后面就是字母和数字或下划线构成，长度5-20"><a href="#43-请写一个正则，匹配输入的字符：第一个必须是字母或下划线开头，后面就是字母和数字或下划线构成，长度5-20" class="headerlink" title="43.请写一个正则，匹配输入的字符：第一个必须是字母或下划线开头，后面就是字母和数字或下划线构成，长度5-20."></a>43.请写一个正则，匹配输入的字符：第一个必须是字母或下划线开头，后面就是字母和数字或下划线构成，长度5-20.</h4><p>答案： /^[A-Za-z_]\w{4,19}$/</p>
<h4 id="44-JS中原型链最上层的对象是-object-的原型对象，该对象的-proto-指针指向-null-的原型对象。"><a href="#44-JS中原型链最上层的对象是-object-的原型对象，该对象的-proto-指针指向-null-的原型对象。" class="headerlink" title="44.JS中原型链最上层的对象是  object  的原型对象，该对象的_proto_指针指向  null    的原型对象。"></a>44.JS中原型链最上层的对象是  object  的原型对象，该对象的_proto_指针指向  null    的原型对象。</h4><h4 id="45-JS中使用-Object-对象的-defineProperty-函数定义对象属性的访问器。"><a href="#45-JS中使用-Object-对象的-defineProperty-函数定义对象属性的访问器。" class="headerlink" title="45.JS中使用 Object 对象的   defineProperty    函数定义对象属性的访问器。"></a>45.JS中使用 Object 对象的   defineProperty    函数定义对象属性的访问器。</h4><h4 id="46-如何对一篇文章进行敏感词替换？假如有几千个敏感词。（写一下思路即可）"><a href="#46-如何对一篇文章进行敏感词替换？假如有几千个敏感词。（写一下思路即可）" class="headerlink" title="46.如何对一篇文章进行敏感词替换？假如有几千个敏感词。（写一下思路即可）"></a>46.如何对一篇文章进行敏感词替换？假如有几千个敏感词。（写一下思路即可）</h4><p>将这篇文章以字符串的形式赋给一个变量。定义一个正则表达式，以全局匹配的方式查找所有敏感词，并用replace方法替换掉</p>
<h4 id="47-添加、删除、更改、插入节点的方法"><a href="#47-添加、删除、更改、插入节点的方法" class="headerlink" title="47.添加、删除、更改、插入节点的方法"></a>47.添加、删除、更改、插入节点的方法</h4><p>appendChild</p>
<p>removeChild</p>
<p>replaceChild</p>
<p>insertBefore</p>
<h4 id="48-在javascript编程中，请至少说出三种异步操作的使用场景？"><a href="#48-在javascript编程中，请至少说出三种异步操作的使用场景？" class="headerlink" title="48.在javascript编程中，请至少说出三种异步操作的使用场景？"></a>48.在javascript编程中，请至少说出三种异步操作的使用场景？</h4><p>回调函数</p>
<p>事件监听</p>
<p>Promise对象</p>
<p>Nodejs的异步方法</p>
<h4 id="49-知道不知道事件冒泡？知不知道阻止浏览器的默认行为？对应的原生兼容性写法该怎么写"><a href="#49-知道不知道事件冒泡？知不知道阻止浏览器的默认行为？对应的原生兼容性写法该怎么写" class="headerlink" title="49.知道不知道事件冒泡？知不知道阻止浏览器的默认行为？对应的原生兼容性写法该怎么写"></a>49.知道不知道事件冒泡？知不知道阻止浏览器的默认行为？对应的原生兼容性写法该怎么写</h4><p>事件冒泡</p>
<p>父元素和子元素上面的话都添加的有click（不仅仅是click事件，只要保证是同一个事件即可）。子元素的click事件触发的时候，会导致该click事件冒泡到它的父元素上面，为了阻止父元素的事件触发，我们一般需要给子元素的事件里写上阻止事件冒泡的方法</p>
<p>场景：（下拉菜单）点击空白区域关闭下拉菜单</p>
<p>兼容性写法：</p>
<p>if(event.stopPropagation){</p>
<p>​    event.stopPropagation();</p>
<p>}else if(event.cancelBubble){</p>
<p>​    event.cancelBubble = true;</p>
<p>}</p>
<p>阻止浏览器默认行为</p>
<p>当我们不希望一些浏览器默认行为触发的时候，就需要给对应的事件添加上阻止浏览器默认行为。</p>
<p>场景：</p>
<p>禁止a链接的点击后发生跳转</p>
<p>禁止UC等手机浏览器左右滑动切换到前一页或者下一页(我们可以通过给document的touchmove事件加上阻止浏览器默认行为的方法)</p>
<h4 id="50-什么是闭包（closure），为什么要用它？"><a href="#50-什么是闭包（closure），为什么要用它？" class="headerlink" title="50.什么是闭包（closure），为什么要用它？"></a>50.什么是闭包（closure），为什么要用它？</h4><p>闭包就是能够读取其他函数内部变量的函数，如果一个函数内部又定义了一个内部函数，并将该内部函数作为返回值返回或者存储在某个对象的属性里，这时就会形成一个闭包。</p>
<p>使用场景：1.匿名自执行函数   2缓存  3实现封装（封装的方式有很多，闭包只是其中一种，不是说到封装就一定会用闭包）</p>
<p>闭包的优缺点</p>
<p>闭包的优点：</p>
<p>1.缓存</p>
<p>2.面向对象中的对象</p>
<p>3.实现封装，防止变量跑到外层作用域中，发生命名冲突</p>
<p>4.匿名自执行函数，匿名自执行函数可以减小内存消耗</p>
<p>5.提升变量的作用域链</p>
<p>闭包的缺点：</p>
<p>1.闭包有一个非常严重的问题，那就是内存浪费问题，这个内存浪费不仅仅因为它常驻内存，更重要的是，对闭包的使用不当的话会造成无效内存的产生</p>
<p>2.性能问题 使用闭包时，会涉及到跨作用域访问，每次访问都会导致性能损失。</p>
<p>因此在脚本中，最好小心使用闭包，它同时会涉及到内存和速度问题。不过我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响。</p>
<h4 id="51-知道原型和原型链么，一般什么时候需要用？"><a href="#51-知道原型和原型链么，一般什么时候需要用？" class="headerlink" title="51.知道原型和原型链么，一般什么时候需要用？"></a>51.知道原型和原型链么，一般什么时候需要用？</h4><p>原型：</p>
<p>主要作用是用于继承</p>
<p>原型的作用是为函数对象声明通用的变量或者函数，构造函数的实例都会从原型上继承属性和方法。</p>
<p>每个对象中都有<strong>proto</strong>属性，这个属性指向的就是它基于的原型对象。</p>
<p>原型链：</p>
<p>var person = function(name){</p>
<p>   this.name = name</p>
<p>  };</p>
<p>  person.prototype.getName = function(){</p>
<p>​     return this.name;</p>
<p>  }</p>
<p>  var zjh = new person(‘zhangjiahao’);</p>
<p>  zjh.getName(); //zhangjiahao</p>
<p>JS在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做<strong>proto</strong>的内置属性，用于指向创建它的函数对象的原型对象prototype。以上面的例子为例：</p>
<p>  console.log(zjh.<strong>proto</strong> === person.prototype) //true</p>
<p>同样，person.prototype对象也有<strong>proto</strong>属性，它指向创建它的函数对象（Object）的prototype</p>
<p>  console.log(person.prototype.<strong>proto</strong> === Object.prototype)//true</p>
<p>继续，Object.prototype对象也有<strong>proto</strong>属性，但它比较特殊，为null</p>
<p>  console.log(Object.prototype.<strong>proto</strong>) //null</p>
<p>我们把这个有<strong>proto</strong>串起来的直到Object.prototype.<strong>proto</strong>为null的链叫做原型链</p>
<p>我们调用一个对象的属性或者方法的时候，会存在一个优先级的问题。优先级为：</p>
<p>构造函数内定义的属性&gt;构造函数的原型上定义的属性&gt;沿着<strong>proto</strong>指定的原型（原型链）一直往上找，直到找到null为止。任何一步一旦找到就立马停止，不会继续往下找。</p>
<h4 id="52-有没有封装过插件，你一般怎么封装呢"><a href="#52-有没有封装过插件，你一般怎么封装呢" class="headerlink" title="52.有没有封装过插件，你一般怎么封装呢"></a>52.有没有封装过插件，你一般怎么封装呢</h4><p>逼格低点的话这样说：</p>
<p>封装过，以前我主要是把一些公共的功能封装成函数来实现简单封装，比如tab切换封装的时候我会定义一个叫tab的函数，选项卡节点和内容节点作为函数tab的参数。假如我一个页面有多个tab切换，我只需要执行函数的时候给函数传入不同的参数即可。</p>
<p>逼格高点的这样说：</p>
<p>封装过，我们主要用面向对象中的混合模式来封装插件，把可变的属性或者方法（通常都是属性）在构造函数内定义，把一些不变的属性或者方法（通常是方法）定义在函数的原型上面。我们封装好的插件通常会放在一个匿名自执行函数里面，这样做的目的是为了避免变量冲突。</p>
<h4 id="53-Ajax和jsonp的原理？"><a href="#53-Ajax和jsonp的原理？" class="headerlink" title="53.Ajax和jsonp的原理？"></a>53.Ajax和jsonp的原理？</h4><p>Ajax的原理（最次最次也得把XMLHttpRequest对象说出来）</p>
<p>Ajax基于XMLHttpRequest对象与Web服务器端进行异步数据通信。</p>
<p>首先基于这个对象的open方法创建一个浏览器跟服务器端连接，通过send方法从浏览器向服务器端发送请求。我们可以通过这个对象的onreadystatechange事件来监听请求的状态，当请求成功之后的话，我可以获取到这个对象responseText等方法获取到请求过来的数据，然后通过js对这些数据进行解析</p>
<p>Jsonp原理</p>
<p>Ajax不能跨域，但是script标签和img标签都可以跨域。jsonp的话就是动态创建一个script标签，把jsonp数据格式(callback(json))的接口的地址赋值给我们的script标签的src属性。每一次发送jsonp请求的时候都会创建一个全局的回调函数，全局回调函数名称跟我们jsonp接口里面的函数名称是一致的。全局函数里面写的就是对请求过来数据的操作。</p>
<p>Ajax不能跨域，JSONP可以跨域。 </p>
<h4 id="54-你们移动端怎么开发的？用的什么单位、js框架呢、怎么真机调试你们程序、怎么解决前缀问题呢"><a href="#54-你们移动端怎么开发的？用的什么单位、js框架呢、怎么真机调试你们程序、怎么解决前缀问题呢" class="headerlink" title="54.你们移动端怎么开发的？用的什么单位、js框架呢、怎么真机调试你们程序、怎么解决前缀问题呢"></a>54.你们移动端怎么开发的？用的什么单位、js框架呢、怎么真机调试你们程序、怎么解决前缀问题呢</h4><p>首先我们移动端用的是rem这个单位，移动端实际上还新增了vw,vh等一些单位，但是相对于rem来说，他们的兼容性都不好。rem是一个相对单位，是相对于根节点的font-size的比例。我们还会引用一个外部的js，这个js可以通过屏幕宽度动态计算根节点的font-size值。</p>
<p>我们移动端用的JS框架是zepto.js，因为相应来说它的的体积的话要小很多。而且我们项目中有时会需要使用一些触屏事件，比如滑动事件，那么我们还会调用它里面的touch模块</p>
<p>我们webapp的话都是基于gulp搭建的前端工程来开发，因为利用gulp起一个webserver特别简单，并且我还可以实现livereload功能（当我监控的文件发生变化的时候，可以触发浏览器的自动刷新功能），而且在css3里面加前缀的话是一个很头疼的问题，我们现在只需要用autoprefixer模块就可以很容易实现自动加css3前缀这个功能了。</p>
<h4 id="55-移动端兼容性？"><a href="#55-移动端兼容性？" class="headerlink" title="55.移动端兼容性？"></a>55.移动端兼容性？</h4><p>1&gt;ios移动端click事件300ms的延迟响应. 用fastclick来解决</p>
<p>2&gt;zepto的touch模块的tap事件有点透的问题，也是用fastclick来解决</p>
<p>3&gt;一些情况下对非可点击元素如(label,span)监听click事件，ios下不会触发，css增加cursor:pointer就搞定了</p>
<p>4&gt;ios下取消input在输入的时候英文首字母的默认大写</p>
<p>&lt;input autocapitalize=”off”autocorrect=”off” /&gt;</p>
<p>5&gt;fixed定位缺陷</p>
<p>ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位</p>
<p>android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位</p>
<p>ios4下不支持position:fixed</p>
<p>解决方案： 可用iScroll插件解决这个问题</p>
<p>6&gt;Input 的placeholder会出现文本位置偏上的情况</p>
<p>input 的placeholder会出现文本位置偏上的情况：PC端设置line-height等于height能够对齐，而移动端仍然是偏上，解决是设置line-height：normal</p>
<p>7&gt;calc的兼容性处理</p>
<p>CSS3中的calc变量在iOS6浏览器中必须加-webkit-前缀，目前的FF浏览器已经无需-moz-前缀。</p>
<p>Android浏览器目前仍然不支持calc，所以要在之前增加一个保守尺寸：</p>
<p>div {</p>
<p>​    width: 95%;</p>
<p>​    width: -webkit-calc(100% - 50px);</p>
<p>​    width: calc(100% - 50px);</p>
<p>}</p>
<p>8&gt;在移动端修改难看的点击的高亮效果，iOS和安卓下都有效：</p>
<p>\ {-webkit-tap-highlight-color:rgba(0,0,0,0);}</p>
<p>9&gt;阻止旋转屏幕时自动调整字体大小</p>
<p>html, body, form, fieldset, p, div, h1, h2, h3, h4, h5,h6 {-webkit-text-size-adjust:none;}</p>
<h4 id="57-谈谈你对bootstrap的认识，用它做过项目么？"><a href="#57-谈谈你对bootstrap的认识，用它做过项目么？" class="headerlink" title="57.谈谈你对bootstrap的认识，用它做过项目么？"></a>57.谈谈你对bootstrap的认识，用它做过项目么？</h4><p>用Bootstrap主要用来做一些响应式的网站，它里面栅格化这块比较强大，我可以针对不同的屏幕尺寸定制不同页面结构。</p>
<p>我还用它做过后台管理系统，因为它里面集成的有风格标准统一的组件、插件、全局样式等，是我们做后台管理系统的话，不用再花大精力去布局页面了。而且甚至产品给我们一个原型图我们就可以开始开发，大大提高了开发效率。</p>
<h4 id="58-javascript-继承的-6-种方法？"><a href="#58-javascript-继承的-6-种方法？" class="headerlink" title="58.javascript 继承的 6 种方法？"></a>58.javascript 继承的 6 种方法？</h4><ol>
<li>原型链继承</li>
<li>借用构造函数继承</li>
<li>组合继承(原型+借用构造)</li>
<li>原型式继承</li>
<li>寄生式继承</li>
<li>寄生组合式继承</li>
</ol>
<h4 id="59-简述创建函数的几种方式"><a href="#59-简述创建函数的几种方式" class="headerlink" title="59.简述创建函数的几种方式"></a>59.简述创建函数的几种方式</h4><p>第一种（函数声明）：<br>function sum1(num1,num2){<br>return num1+num2;<br>}
第二种（函数表达式）：<br>var sum2 = function(num1,num2){<br>return num1+num2;<br>}
匿名函数：<br>function(){}:只能自己执行自己</p>
<h4 id="60-把-Script-标签-放在页面的最底部的-body-封闭之前-和封闭之后有什么区别？浏览器会如何解析它们？"><a href="#60-把-Script-标签-放在页面的最底部的-body-封闭之前-和封闭之后有什么区别？浏览器会如何解析它们？" class="headerlink" title="60.把 Script 标签 放在页面的最底部的 body 封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？"></a>60.把 Script 标签 放在页面的最底部的 body 封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？</h4><p>如果说放在 body 的封闭之前，将会阻塞其他资源的加载<br>如果放在 body 封闭之后，不会影响 body </p>
<h4 id="61-js-延迟加载的方式有哪些？"><a href="#61-js-延迟加载的方式有哪些？" class="headerlink" title="61.js 延迟加载的方式有哪些？"></a>61.js 延迟加载的方式有哪些？</h4><ol>
<li>defer 和 async</li>
<li>动态创建 DOM 方式（创建 script，插入到 DOM 中，加载完毕后 callBack）</li>
<li>按需异步载入 js</li>
</ol>
<h4 id="62-数组方法-pop-push-unshift-shift-各表示什么意思？"><a href="#62-数组方法-pop-push-unshift-shift-各表示什么意思？" class="headerlink" title="62.数组方法 pop() push() unshift() shift()各表示什么意思？"></a>62.数组方法 pop() push() unshift() shift()各表示什么意思？</h4><p>答：Push()尾部添加、pop()尾部删除、Unshift()头部添加、shift()头部删除</p>
<h4 id="63-Javascript-中-callee-和-caller-的作用？"><a href="#63-Javascript-中-callee-和-caller-的作用？" class="headerlink" title="63.Javascript 中 callee 和 caller 的作用？"></a>63.Javascript 中 callee 和 caller 的作用？</h4><p>caller 是返回一个对函数的引用，该函数调用了当前函数；<br>用法：fn.caller<br>callee 是返回正在被执行的 function 函数，也就是所指定的 function 对象的正文。<br>用法：arguments.callee</p>
<h4 id="64-jquery-extend-与-jquery-fn-extend-的区别？"><a href="#64-jquery-extend-与-jquery-fn-extend-的区别？" class="headerlink" title="64.jquery.extend 与 jquery.fn.extend 的区别？"></a>64.jquery.extend 与 jquery.fn.extend 的区别？</h4><p>Jquery.extend 用来扩展 jQuery 对象本身；jquery.fn.extend 用来扩展 jQuery 原型对象</p>
<h4 id="65-jQuery-和-Zepto-的区别？各自的使用场景？"><a href="#65-jQuery-和-Zepto-的区别？各自的使用场景？" class="headerlink" title="65.jQuery 和 Zepto 的区别？各自的使用场景？"></a>65.jQuery 和 Zepto 的区别？各自的使用场景？</h4><p>jQuery 主要用于 pc 端，当然有对应的 jQuerymobile 用于移动端，zepto 比 jQuery 更加小巧，主要用于移动端<br>jquer mobile 相对于 zepto 功能强大，但是体积也很庞大，zepto 非常的轻量</p>
<h4 id="66-Zepto-的点透问题如何解决？"><a href="#66-Zepto-的点透问题如何解决？" class="headerlink" title="66.Zepto 的点透问题如何解决？"></a>66.Zepto 的点透问题如何解决？</h4><p>点透主要是由于两个 div 重合，例如：一个 div 调用 show()，一个 div 调用 hide()；<br>这个时候当点击上面的 div 的时候就会影响到下面的那个 div；<br>解决办法主要有 2 种：<br>1.github 上有一个叫做 fastclick 的库，它也能规避移动设备上 click 事件的延迟响应，<a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">https://github.com/ftlabs/fastclick</a><br>将它用 script 标签引入页面（该库支持 AMD，于是你也可以按照 AMD 规范，用诸如require.js 的模块加载器引入），并且在 dom ready 时初始化在 body 上，<br>2.根据分析，如果不引入其它类库，也不想自己按照上述 fastclcik 的思路再开发一套东西，需要 1.一个优先于下面的“divClickUnder”捕获的事件；2.并且通过这个事件阻止掉默认行为（下面的“divClickUnder”对 click 事件的捕获，在 ios 的 safari，click 的捕获被认为和滚屏、点击输入框弹起键盘等一样，是一种浏览器默认行为，即可以被 event.preventDefault()阻止的行为）。</p>
<h4 id="67-事件绑定和普通事件有什么区别"><a href="#67-事件绑定和普通事件有什么区别" class="headerlink" title="67.事件绑定和普通事件有什么区别"></a>67.事件绑定和普通事件有什么区别</h4><p>传统事件绑定和符合 W3C 标准的事件绑定有什么区别？<br>div1.onclick=function(){};</p>
<p>1、如果说给同一个元素绑定了两次或者多次相同类型的事件，那么后面的绑定会覆盖前面的绑定<br>2、不支持 DOM 事件流 事件捕获阶段目标元素阶段=&gt;事件冒泡阶段</p>
<p>addEventListener<br>1、 如果说给同一个元素绑定了两次或者多次相同类型的事件，所有的绑定将会依次触发<br>2、 支持 DOM 事件流的<br>3、 进行事件绑定传参不需要 on 前缀</p>
<p>addEventListener(“click”,function(){},true);//此时的事件就是在事件冒泡阶段执行<br>ie9 开始，ie11 edge：addEventListener<br>ie9 以前：attachEvent/detachEvent<br>1、 进行事件类型传参需要带上 on 前缀<br>2、 这种方式只支持事件冒泡，不支持事件捕获<br>事件绑定是指把事件注册到具体的元素之上，普通事件指的是可以用来注册的事件</p>
<h4 id="68-IE-和标准下有哪些兼容性的写法"><a href="#68-IE-和标准下有哪些兼容性的写法" class="headerlink" title="68.IE 和标准下有哪些兼容性的写法"></a>68.IE 和标准下有哪些兼容性的写法</h4><p>var ev = ev || window.event<br>document.documentElement.clientWidth || document.body.clientWidth<br>var target = ev.srcElement||ev.target</p>
<h4 id="69-iframe-的优缺点？"><a href="#69-iframe-的优缺点？" class="headerlink" title="69.iframe 的优缺点？"></a>69.iframe 的优缺点？</h4><p>优点：</p>
<ol>
<li>解决加载缓慢的第三方内容如图标和广告等的加载问题</li>
<li>Security sandbox</li>
<li>并行加载脚本<br>缺点：</li>
<li>iframe 会阻塞主页面的 Onload 事件</li>
<li>即时内容为空，加载也需要时间</li>
<li>没有语意</li>
</ol>
<h4 id="70-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点"><a href="#70-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="70.DOM 操作——怎样添加、移除、移动、复制、创建和查找节点"></a>70.DOM 操作——怎样添加、移除、移动、复制、创建和查找节点</h4><ol>
<li>创建新节点<br>createDocumentFragment() // 创建一个 DOM 片段<br>createElement() // 创建一个具体的元素<br>createTextNode() // 创建一个文本节点</li>
<li>添加、移除、替换、插入<br>appendChild()<br>removeChild()<br>replaceChild()<br>insertBefore() // 在已有的子节点前插入一个新的子节点</li>
<li>查找<br>getElementsByTagName() // 通过标签名称<br>getElementsByName() // 通过元素的 Name 属性的值(IE 容错能力较强，会得到一个数组，<br>其中包括 id 等于 name 值的)<br>getElementById() // 通过元素 Id，唯一性</li>
</ol>
<h4 id="71-js-延迟加载的方式有哪些？"><a href="#71-js-延迟加载的方式有哪些？" class="headerlink" title="71.js 延迟加载的方式有哪些？"></a>71.js 延迟加载的方式有哪些？</h4><ol>
<li>defer 和 async</li>
<li>动态创建 DOM 方式（创建 script，插入到 DOM 中，加载完毕后 callBack）</li>
<li>按需异步载入 js</li>
</ol>
<h4 id="72-documen-write-和-innerHTML-的区别？"><a href="#72-documen-write-和-innerHTML-的区别？" class="headerlink" title="72.documen.write 和 innerHTML 的区别？"></a>72.documen.write 和 innerHTML 的区别？</h4><p>document.write 只能重绘整个页面<br>innerHTML 可以重绘页面的一部分</p>
<h4 id="73-哪些操作会造成内存泄漏？"><a href="#73-哪些操作会造成内存泄漏？" class="headerlink" title="73.哪些操作会造成内存泄漏？"></a>73.哪些操作会造成内存泄漏？</h4><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。<br>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p>
<ol>
<li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</li>
<li>闭包</li>
<li>控制台日志</li>
<li>循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li>
</ol>
<h4 id="74-window-location-search-返回的是什么？"><a href="#74-window-location-search-返回的是什么？" class="headerlink" title="74.window.location.search 返回的是什么？"></a>74.window.location.search 返回的是什么？</h4><p>答：查询(参数)部分。除了给动态语言赋值以外，我们同样可以给静态页面, 并使用 javascript 来获得相信应的参数值。<br>返回值：?ver=1.0&amp;id=timlq 也就是问号后面的！</p>
<h4 id="75-window-location-hash-返回的是什么？"><a href="#75-window-location-hash-返回的是什么？" class="headerlink" title="75.window.location.hash 返回的是什么？"></a>75.window.location.hash 返回的是什么？</h4><p>答：锚点</p>
<h4 id="76-window-location-reload-作用？"><a href="#76-window-location-reload-作用？" class="headerlink" title="76.window.location.reload() 作用？"></a>76.window.location.reload() 作用？</h4><p>答：刷新当前页面。</p>
<h4 id="77-BOM-对象有哪些，列举-window-对象？"><a href="#77-BOM-对象有哪些，列举-window-对象？" class="headerlink" title="77.BOM 对象有哪些，列举 window 对象？"></a>77.BOM 对象有哪些，列举 window 对象？</h4><p>1、window 对象 ，是 JS 的最顶层对象，其他的 BOM 对象都是 window 对象的属性；<br>2、document 对象，文档对象；<br>3、location 对象，浏览器当前 URL 信息；<br>4、navigator 对象，浏览器本身信息；<br>5、screen 对象，客户端屏幕信息；<br>6、history 对象，浏览器访问历史信息；</p>
<h4 id="78-请问代码实现-outerHTML"><a href="#78-请问代码实现-outerHTML" class="headerlink" title="78.请问代码实现 outerHTML"></a>78.请问代码实现 outerHTML</h4><p>说明：outerHTML 其实就是 innerHTML 再加上本身；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.outerHTML = function()&#123;</span><br><span class="line">    var innerCon = this.innerHTML, //获得里面的内容</span><br><span class="line">    outerCon = this.appendChild(innerCon); //添加到里面</span><br><span class="line">    alert(outerCon);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="79-你如何优化自己的代码？"><a href="#79-你如何优化自己的代码？" class="headerlink" title="79.你如何优化自己的代码？"></a>79.你如何优化自己的代码？</h4><p>代码重用<br>避免全局变量（命名空间，封闭空间，模块化 mvc..）<br>拆分函数避免函数过于臃肿：单一职责原则<br>适当的注释，尤其是一些复杂的业务逻辑或者是计算逻辑，都应该写出这个业务逻辑的具体过程<br>内存管理，尤其是闭包中的变量释放</p>
<h4 id="80-列举常用的-js-框架以及分别适用的领域"><a href="#80-列举常用的-js-框架以及分别适用的领域" class="headerlink" title="80.列举常用的 js 框架以及分别适用的领域"></a>80.列举常用的 js 框架以及分别适用的领域</h4><p>jquery：简化了 js 的一些操作，并且提供了一些非常好用的 API<br>jquery ui、jquery-easyui：在 jqeury 的基础上提供了一些常用的组件 日期，下拉框，表格这<br>些组件<br>require.js、sea.js（阿里的玉帛）+》模块化开发使用的<br>zepto：精简版的 jquery，常用于手机 web 前端开发 提供了一些手机页面实用功能,touch<br>ext.js：跟 jquery 差不多，但是不开源，也没有 jquery 轻量<br>angular、knockoutjs、avalon(去哪儿前端总监)：MV*框架，适合用于单页应用开发(SPA)</p>
<h4 id="81-JavaScript-数组元素添加、删除、排序等方法有哪些？"><a href="#81-JavaScript-数组元素添加、删除、排序等方法有哪些？" class="headerlink" title="81.JavaScript 数组元素添加、删除、排序等方法有哪些？"></a>81.JavaScript 数组元素添加、删除、排序等方法有哪些？</h4><p>Array.concat( ) 连接数组<br>Array.join( ) 将数组元素连接起来以构建一个字符串<br>Array.length 数组的大小<br>Array.pop( ) 删除并返回数组的最后一个元素<br>Array.push( ) 给数组添加元素<br>Array.reverse( ) 颠倒数组中元素的顺序<br>Array.shift( ) 将元素移出数组<br>Array.slice( ) 返回数组的一部分<br>Array.sort( ) 对数组元素进行排序<br>Array.splice( ) 插入、删除或替换数组的元素<br>Array.toLocaleString( ) 把数组转换成局部字符串<br>Array.toString( ) 将数组转换成一个字符串<br>Array.unshift( ) 在数组头部插入一个元素</p>
<h4 id="82-如何添加-html-元素的事件，有几种方法？请列举"><a href="#82-如何添加-html-元素的事件，有几种方法？请列举" class="headerlink" title="82.如何添加 html 元素的事件，有几种方法？请列举"></a>82.如何添加 html 元素的事件，有几种方法？请列举</h4><p>a、直接在标签里添加：这是一个层<br>b、在元素上通过 js 添加:<br>c、使用事件注册函数添加</p>
<h4 id="83-使用闭包实现点击每一列的时候-alert-其-index？"><a href="#83-使用闭包实现点击每一列的时候-alert-其-index？" class="headerlink" title="83.使用闭包实现点击每一列的时候 alert 其 index？"></a>83.使用闭包实现点击每一列的时候 alert 其 index？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;test&quot;&gt;</span><br><span class="line">    &lt;li&gt;这是第一条&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;这是第二条&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;这是第三条&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">var lis=document.querySelectorAll(&apos;li&apos;);</span><br><span class="line">for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">    var li = lis[i];</span><br><span class="line">    li.onclick=(function(index)&#123;</span><br><span class="line">        return function(e)&#123;</span><br><span class="line">        alert(index);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="84-列出-3-条以上-ff-和-IE-的脚本兼容问题"><a href="#84-列出-3-条以上-ff-和-IE-的脚本兼容问题" class="headerlink" title="84.列出 3 条以上 ff 和 IE 的脚本兼容问题"></a>84.列出 3 条以上 ff 和 IE 的脚本兼容问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1、在 IE 下和火狐下事件冒泡不一样</span><br><span class="line"></span><br><span class="line">2、IE 的写法： tbody=table.childNodes[0]</span><br><span class="line">	在 FF 中，firefox 会在子节点中包含空白则第一个子节点为空白&quot;&quot;， 而 ie 不会返回空白</span><br><span class="line">	可以通过 if(&quot;&quot; != node.nodeName)过滤掉空白子对象</span><br><span class="line"></span><br><span class="line">3、模拟点击事件</span><br><span class="line">if(document.all)&#123; //ie 下</span><br><span class="line">	document.getElementById(&quot;a3&quot;).click();</span><br><span class="line">&#125;</span><br><span class="line">else&#123; //非 IE</span><br><span class="line">	var evt = document.createEvent(&quot;MouseEvents&quot;);</span><br><span class="line">	evt.initEvent(&quot;click&quot;, true, true);</span><br><span class="line">	document.getElementById(&quot;a3&quot;).dispatchEvent(evt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4、事件注册</span><br><span class="line">if (isIE)&#123;window.attachEvent(&quot;onload&quot;, init);&#125;else&#123;window.addEventListener(&quot;load&quot;, </span><br><span class="line"></span><br><span class="line">5、ajax对象的获取</span><br><span class="line"></span><br><span class="line">6、firstElement等返回结果不一样</span><br></pre></td></tr></table></figure>

<h4 id="85-在-Javascript-中什么是伪数组？如何将伪数组转化为标准数组？"><a href="#85-在-Javascript-中什么是伪数组？如何将伪数组转化为标准数组？" class="headerlink" title="85.在 Javascript 中什么是伪数组？如何将伪数组转化为标准数组？"></a>85.在 Javascript 中什么是伪数组？如何将伪数组转化为标准数组？</h4><p>伪数组（类数组）：无法直接调用数组方法或期望 length 属性有什么特殊的行为，但仍可<br>以对真正数组遍历方法来遍历它们。典型的是函数的 argument 参数，还有像调用<br>getElementsByTagName,document.childNodes 之类的,它们都返回 NodeList 对象都属于伪<br>数组。<br>可以使用 Array.prototype.slice.call(fakeArray)将数组转化为真正的 Array 对象。</p>
<h4 id="86-正则表达式构造函数-var-reg-new-RegExp-“xxx”-与正则表达字面量-var"><a href="#86-正则表达式构造函数-var-reg-new-RegExp-“xxx”-与正则表达字面量-var" class="headerlink" title="86.正则表达式构造函数 var reg=new RegExp(“xxx”)与正则表达字面量 var"></a>86.正则表达式构造函数 var reg=new RegExp(“xxx”)与正则表达字面量 var</h4><p>reg=//有什么不同？匹配邮箱的正则表达式？<br>答案：当使用 RegExp()构造函数的时候，不仅需要转义引号（即\”表示”），并且还需要<br>双反斜杠（即\表示一个\）。使用正则表达字面量的效率更高。</p>
<h4 id="87-jQuery-的-slideUp-动画-，如果目标元素是被外部事件驱动-当鼠标快速地连续触发外部元素事件-动画会滞后的反复执行，该如何处理呢"><a href="#87-jQuery-的-slideUp-动画-，如果目标元素是被外部事件驱动-当鼠标快速地连续触发外部元素事件-动画会滞后的反复执行，该如何处理呢" class="headerlink" title="87.jQuery 的 slideUp 动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?"></a>87.jQuery 的 slideUp 动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?</h4><p>先 stop(true,true)后 slideUp()</p>
<h4 id="88-javascript-的本地对象，内置对象和宿主对象"><a href="#88-javascript-的本地对象，内置对象和宿主对象" class="headerlink" title="88.javascript 的本地对象，内置对象和宿主对象"></a>88.javascript 的本地对象，内置对象和宿主对象</h4><p>本地对象为独立于宿主环境的 ECMAScript 提供的对象，包括 Array Object RegExp 等可以 new 实例化的对象<br>内置对象为 Gload，Math 等不可以实例化的(他们也是本地对象，内置对象是本地对象的一个子集)<br>宿主对象为所有的非本地对象，所有的 BOM 和 DOM 对象都是宿主对象，如浏览器自带的document,window 等对象</p>
<h4 id="89-请说出三种减低页面加载时间的方法"><a href="#89-请说出三种减低页面加载时间的方法" class="headerlink" title="89.请说出三种减低页面加载时间的方法"></a>89.请说出三种减低页面加载时间的方法</h4><p>1、压缩 css、js 文件<br>2、合并 js、css 文件，减少 http 请求<br>3、外部 js、css 文件放在最底下<br>4、减少 dom 操作，尽可能用变量替代不必要的 dom 操作</p>
<h4 id="90-Javascript-作用域链"><a href="#90-Javascript-作用域链" class="headerlink" title="90.Javascript 作用域链?"></a>90.Javascript 作用域链?</h4><p>JavaScript有全局作用域和局部作用域，没有块作用域，函数的嵌套形成不同层次的作用域，嵌套的层次形成链式形式，通过作用域链查找属性的规则需要深入理解。</p>
<h4 id="91-eval-是做什么的？"><a href="#91-eval-是做什么的？" class="headerlink" title="91. eval 是做什么的？"></a>91. eval 是做什么的？</h4><p>它的功能是把对应的字符串解析成 JS 代码并运行；应该避免使用 eval，不安全，非常耗性能（2 个步骤，一次解析成 js 语句，一次执行）</p>
<h4 id="92-javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？"><a href="#92-javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？" class="headerlink" title="92.javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？"></a>92.javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</h4><p>意思是使用严格模式，使用严格模式，一些不规范的语法将不再支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">链接：http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html</span><br><span class="line">全局变量显式声明</span><br><span class="line">静态绑定</span><br><span class="line">禁止使用 with 语句</span><br><span class="line">eval 中定义的变量都是局部变量</span><br><span class="line">禁止 this 关键字指向全局对象</span><br><span class="line">禁止在函数内部遍历调用栈</span><br><span class="line">严格模式下无法删除变量。只有 configurable 设置为 true 的对象属性，才能被删除</span><br><span class="line">正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，</span><br><span class="line">将报错。</span><br><span class="line">严格模式下，对一个使用 getter 方法读取的属性进行赋值，会报错。</span><br><span class="line">严格模式下，对禁止扩展的对象添加新属性，会报错。</span><br><span class="line">严格模式下，删除一个不可删除的属性，会报错。</span><br><span class="line">正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，</span><br><span class="line">这属于语法错误。</span><br><span class="line">正常模式下，如果函数有多个重名的参数，可以用 arguments[i]读取。严格模式下，这属于</span><br><span class="line">语法错误。</span><br><span class="line">正常模式下，整数的第一位如果是 0，表示这是八进制数，比如 0100 等于十进制的 64。严</span><br><span class="line">格模式禁止这种表示法，整数第一位为 0，将报错。</span><br><span class="line">不允许对 arguments 赋值</span><br><span class="line">arguments 不再追踪参数的变化</span><br><span class="line">禁止使用 arguments.callee</span><br><span class="line">严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的</span><br><span class="line">代码块内声明函数</span><br><span class="line">严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。</span><br></pre></td></tr></table></figure>

<h4 id="93-Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"><a href="#93-Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？" class="headerlink" title="93.Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"></a>93.Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</h4><p>HasOwnProperty</p>
<h4 id="94-js模块化规范"><a href="#94-js模块化规范" class="headerlink" title="94.js模块化规范"></a>94.js模块化规范</h4><p>浏览器端 requirejs，seajs；</p>
<p>服务器端 commonJS；</p>
<p>ES6 模块化；fis</p>
<h4 id="95-gulp、grunt、webpack"><a href="#95-gulp、grunt、webpack" class="headerlink" title="95.gulp、grunt、webpack"></a>95.gulp、grunt、webpack</h4><p>gulp、grunt、webpack都是前端自动化构建工具。gulp 和 grunt 非常类似，gulp强调的是前端开发的工作流程，核心都是基于一个个的任务(task)进行项目构建，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程</p>
<p>Webpack与Gulp、Grunt没有什么可比性，它把项目看成一个整体，是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。webpack is a module bundle</p>
<h4 id="96-requireJS-的核心原理是什么？"><a href="#96-requireJS-的核心原理是什么？" class="headerlink" title="96.requireJS 的核心原理是什么？"></a>96.requireJS 的核心原理是什么？</h4><p>核心是 js 的加载模块，通过正则匹配模块以及模块的依赖关系，保证文件加载的先后顺序，根据文件的路径对加载过的文件做了缓存</p>
<h4 id="97-AMD（Modules-Asynchronous-Definition）、CMD（Common-Module-Definition）"><a href="#97-AMD（Modules-Asynchronous-Definition）、CMD（Common-Module-Definition）" class="headerlink" title="97.AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）"></a>97.AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）</h4><p>规范区别？<br>理解这两种规范的差异，主要通过 requirejs 与 seajs 的对比，理解模块的定义与引用方式<br>的差异以及这两种规范的设计原则<br>参考链接 1：<a href="https://www.zhihu.com/question/20351507/answer/14859415" target="_blank" rel="noopener">https://www.zhihu.com/question/20351507/answer/14859415</a><br>参考链接 2：<a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="noopener">https://github.com/seajs/seajs/issues/277</a></p>
<p>1、对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，<br>也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.<br>2、CMD 推崇依赖就近，AMD 推崇依赖前置。</p>
<p>3、AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个API 都简单纯粹。</p>
<h4 id="98-谈一谈你对-ECMAScript6-的了解"><a href="#98-谈一谈你对-ECMAScript6-的了解" class="headerlink" title="98.谈一谈你对 ECMAScript6 的了解"></a>98.谈一谈你对 ECMAScript6 的了解</h4><p>ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。</p>
<p>新特性：变量声明(let const)、解构赋值、字符串扩展(模板字符串)、函数扩展(箭头函数)、数组扩展、对象扩展、Symbol、数据结构(Array\Set\Map)、代理反射、类(Class)、Promise、迭代器(Iterator)、生成器(Generator)</p>
<h4 id="99-Object-对象的常用方法"><a href="#99-Object-对象的常用方法" class="headerlink" title="99.Object 对象的常用方法"></a>99.Object 对象的常用方法</h4><p>Object.hasOwnProperty( ) 检查属性是否被继承<br>Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型<br>Object.propertyIsEnumerable( ) 是否可以通过 for/in 循环看到属性<br>Object.toLocaleString( ) 返回对象的本地字符串表示<br>Object.toString( ) 定义一个对象的字符串表示<br>Object.valueOf( )  指定对象的原始值</p>
<h4 id="100-如何编写高性能的-Javascript？"><a href="#100-如何编写高性能的-Javascript？" class="headerlink" title="100.如何编写高性能的 Javascript？"></a>100.如何编写高性能的 Javascript？</h4><p>使用 DocumentFragment 优化多次 append<br>通过模板元素 clone ，替代 createElement<br>使用一次 innerHTML 赋值代替构建 dom 元素<br>使用 firstChild 和 nextSibling 代替 childNodes 遍历 dom 元素<br>使用 Array 做为 StringBuffer ，代替字符串拼接的操作<br>将循环控制量保存到局部变量<br>顺序无关的遍历时，用 while 替代 for<br>将条件分支，按可能性顺序从高到低排列<br>在同一条件子的多（ &gt;2 ）条件分支时，使用 switch 优于 if<br>使用三目运算符替代条件分支<br>需要不断执行的时候，优先考虑使用 setInterval</p>
<h4 id="101-说说你对-this-的理解？"><a href="#101-说说你对-this-的理解？" class="headerlink" title="101.说说你对 this 的理解？"></a>101.说说你对 this 的理解？</h4><p>在 JavaScript 中，this 通常指向的是我们正在执行的函数本身，或者是，指向该函数所属的对象。<br>全局的 this → 指向的是 Window<br>函数中的 this → 指向的是函数调用者<br>对象中的 this → 指向其本身<br>事件中 this → 指向事件对象</p>
<h4 id="102-分别阐述-split-slice-splice-join-？"><a href="#102-分别阐述-split-slice-splice-join-？" class="headerlink" title="102.分别阐述 split(),slice(),splice(),join()？"></a>102.分别阐述 split(),slice(),splice(),join()？</h4><p>join()用于把数组中的所有元素拼接起来放入一个字符串。所带的参数为分割字符串的分隔<br>符，默认是以逗号分开。归属于 Array<br>split()即把字符串分离开，以数组方式存储。归属于 Stringstring<br>slice() 方法可从已有的数组中返回选定的元素。该方法并不会修改数组，而是返回一个子<br>数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()<br>splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。返回的是含有被删除<br>的元素的数组。</p>
<h4 id="103-jQuery-fn-的-init-方法返回的-this-指的是什么对象？为什么要返回-this？"><a href="#103-jQuery-fn-的-init-方法返回的-this-指的是什么对象？为什么要返回-this？" class="headerlink" title="103.jQuery.fn 的 init 方法返回的 this 指的是什么对象？为什么要返回 this？"></a>103.jQuery.fn 的 init 方法返回的 this 指的是什么对象？为什么要返回 this？</h4><p>this 执行 init 构造函数自身，其实就是 jQuery 实例对象，返回 this 是为了实现 jQuery<br>的链式操作</p>
<h4 id="104-js中如何将数组转化为-json-字符串，然后再转化回来？"><a href="#104-js中如何将数组转化为-json-字符串，然后再转化回来？" class="headerlink" title="104.js中如何将数组转化为 json 字符串，然后再转化回来？"></a>104.js中如何将数组转化为 json 字符串，然后再转化回来？</h4><p>JSON.parse()<br>JSON.stringify()</p>
<h4 id="105-jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝？"><a href="#105-jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝？" class="headerlink" title="105.jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？"></a>105.jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？</h4><p>递归赋值</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/06/10/HTTP/">
                Untitled
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-06-10</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h4 id="1-RESTful"><a href="#1-RESTful" class="headerlink" title="1.RESTful"></a>1.RESTful</h4><p>REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。</p>
<ul>
<li>GET<br><br>get方法在Rest中主要用于获取资源，能够发送参数，不过有限制，且参数都会以?开头的形 式附加在URL尾部。<br>规范的get方法处理器应该是幂等的，也就是说对一个资源不论发送多少次get请求都不会更改数据或造成破坏。</li>
<li>POST<br><br>post方法在Rest请求中主要用于添加资源，参数信息存放在请求报文的消息体中相对安全，且可发送较大信息</li>
<li>PUT<br><br>put方法在Rest中主要用于更新资源，因为大多数浏览器不支持put和delete，会自动将put和delete请求转化为get和post. 因此为了使用put和delete方法,<br>需要以post发送请求，在表单中使用隐藏域发送真正的请求。<br>put方法的参数是同post一样是存放在消息中的，同样具有安全性，可发送较大信息。<br>put方法是幂等的，对同一URL资源做出的同一数据的任意次put请求其对数据的改变都是一致的。</li>
<li>DELETE<br><br>Delete在Rest请求中主要用于删除资源，因为大多数浏览器不支持put和delete，会自动将put和delete请求转化为get和post。<br>因此为了使用put和delete方法,需要以post发送请求，在表单中使用隐藏域发送真正的请求。<br>Delete方法的参数同post一样存放在消息体中,具有安全性，可发送较大信息 Delete方法是幂等的，不论对同一个资源进行多少次delete请求都不会破坏数据</li>
</ul>
<p><a href="https://blog.csdn.net/jnshu_it/article/details/80203696" target="_blank" rel="noopener">https://blog.csdn.net/jnshu_it/article/details/80203696</a></p>
<h4 id="2-GET和POST的区别"><a href="#2-GET和POST的区别" class="headerlink" title="2.GET和POST的区别"></a>2.GET和POST的区别</h4><ul>
<li>GET产生一个TCP数据包；POST产生两个TCP数据包。</li>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>
<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
<li>GET参数通过URL传递，POST放在Request body中。</li>
</ul>
<h4 id="3-Accept和Content-Type"><a href="#3-Accept和Content-Type" class="headerlink" title="3.Accept和Content-Type"></a>3.Accept和Content-Type</h4><p>Accept 请求头用来告知客户端可以处理的内容类型，这种内容类型用MIME类型来表示。<br>服务器使用 Content-Type 应答头通知客户端它的选择。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html</span><br><span class="line">Accept: image/*</span><br><span class="line">Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8</span><br></pre></td></tr></table></figure>

<p>1.Accept属于请求头， Content-Type属于实体头。 <br><br>Http报头分为通用报头，请求报头，响应报头和实体报头。 <br><br>请求方的http报头结构：通用报头|请求报头|实体报头 <br><br>响应方的http报头结构：通用报头|响应报头|实体报头<br></p>
<p>2.Accept代表发送端（客户端）希望接受的数据类型。 <br><br>比如：Accept：text/xml; <br><br>代表客户端希望接受的数据类型是xml类型<br></p>
<p>Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。 <br><br>比如：Content-Type：text/html; <br><br>代表发送端发送的数据格式是html。<br></p>
<p>二者合起来， <br><br>Accept:text/xml； <br><br>Content-Type:text/html <br><br>即代表希望接受的数据类型是xml格式，本次请求发送的数据的数据格式是html。<br></p>
<h4 id="4-状态码"><a href="#4-状态码" class="headerlink" title="4.状态码"></a>4.状态码</h4><table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td>Informational（信息状态码）</td>
<td>接受请求正在处理</td>
</tr>
<tr>
<td>2xx</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3xx</td>
<td>Redirection（重定向状态码）</td>
<td>需要附加操作已完成请求</td>
</tr>
<tr>
<td>4xx</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5xx</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<p>166、HTTP 状态消息 200 302 304 403 404 500 分别表示什么<br>200：请求已成功，请求所希望的响应头或数据体将随此响应返回。<br>302：请求的资源临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当<br>继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，<br>这个响应才是可缓存的<br>304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上<br>次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁<br>止包含消息体，因此始终以消息头后的第一个空行结尾。<br>403：服务器已经理解请求，但是拒绝执行它。<br>404：请求失败，请求所希望得到的资源未被在服务器上发现。<br>500：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这<br>个问题都会在服务器端的源代码出现错误时出现。</p>
<h4 id="5-HTTP缓存"><a href="#5-HTTP缓存" class="headerlink" title="5.HTTP缓存"></a>5.HTTP缓存</h4><p><a href="https://segmentfault.com/a/1190000010690320" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010690320</a></p>
<h4 id="6-如何处理不让别人盗用你的图片，访问你的服务器资源"><a href="#6-如何处理不让别人盗用你的图片，访问你的服务器资源" class="headerlink" title="6.如何处理不让别人盗用你的图片，访问你的服务器资源"></a>6.如何处理不让别人盗用你的图片，访问你的服务器资源</h4><ul>
<li>http header, 对refer做判断看来源是不是自己的网站，如果不是就拒绝</li>
<li>通过session校验，如果不通过特定服务生成cookie和session就不能请求得到资源</li>
</ul>
<p><a href="#HTTP"></a></p>
<h4 id="7-HTTP-协-议-中-，-header-信-息-里-面-，-怎-么-控-制-页-面-失-效-时-间"><a href="#7-HTTP-协-议-中-，-header-信-息-里-面-，-怎-么-控-制-页-面-失-效-时-间" class="headerlink" title="7.HTTP 协 议 中 ， header 信 息 里 面 ， 怎 么 控 制 页 面 失 效 时 间"></a>7.HTTP 协 议 中 ， header 信 息 里 面 ， 怎 么 控 制 页 面 失 效 时 间</h4><p>（last-modified,cache-control,Expires 分别代表什么）</p>
<p><img src="C:%5CUsers%5CAdministrator%5CDesktop%5CFront-end-basic-knowledge-master%5Cassets%5C1549847260584.png" alt="1549847260584"></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/06/10/HTML/">
                Untitled
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-06-10</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h4 id="1-什么是语义化"><a href="#1-什么是语义化" class="headerlink" title="1.什么是语义化"></a>1.什么是语义化</h4><p>用正确的标签做正确的事情。</p>
<p>html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;</p>
<p>搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;</p>
<p>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p>
<p>语义化标签的好处</p>
<ul>
<li>易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。</li>
<li>有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。</li>
<li>方便其他设备解析，如盲人阅读器根据语义渲染网页</li>
<li>有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。</li>
</ul>
<p><a href="http://www.daqianduan.com/6549.html" target="_blank" rel="noopener">http://www.daqianduan.com/6549.html</a></p>
<h4 id="2-cookie、sessionStorage和localStorage的区别。"><a href="#2-cookie、sessionStorage和localStorage的区别。" class="headerlink" title="2.cookie、sessionStorage和localStorage的区别。"></a>2.<code>cookie</code>、<code>sessionStorage</code>和<code>localStorage</code>的区别。</h4><p>上面提到的技术名词，都是在客户端以键值对存储的存储机制，并且只能将值存储为字符串。</p>
<table>
<thead>
<tr>
<th></th>
<th><code>cookie</code></th>
<th><code>localStorage</code></th>
<th><code>sessionStorage</code></th>
</tr>
</thead>
<tbody><tr>
<td>由谁初始化</td>
<td>客户端或服务器，服务器可以使用<code>Set-Cookie</code>请求头。</td>
<td>客户端</td>
<td>客户端</td>
</tr>
<tr>
<td>过期时间</td>
<td>手动设置</td>
<td>永不过期</td>
<td>当前页面关闭时</td>
</tr>
<tr>
<td>在当前浏览器会话（browser sessions）中是否保持不变</td>
<td>取决于是否设置了过期时间</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否随着每个 HTTP 请求发送给服务器</td>
<td>是，Cookies 会通过<code>Cookie</code>请求头，自动发送给服务器</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>容量（每个域名）</td>
<td>4kb</td>
<td>5MB</td>
<td>5MB</td>
</tr>
<tr>
<td>访问权限</td>
<td>任意窗口</td>
<td>任意窗口</td>
<td>当前页面窗口</td>
</tr>
</tbody></table>
<h4 id="3-为什么最好把-CSS-的-lt-link-gt-标签放在-lt-head-gt-lt-head-gt-之间？为什么最好把-JS-的-lt-script-gt-标签恰好放在-lt-body-gt-之前，有例外情况吗？"><a href="#3-为什么最好把-CSS-的-lt-link-gt-标签放在-lt-head-gt-lt-head-gt-之间？为什么最好把-JS-的-lt-script-gt-标签恰好放在-lt-body-gt-之前，有例外情况吗？" class="headerlink" title="3.为什么最好把 CSS 的&lt;link&gt;标签放在&lt;head&gt;&lt;/head&gt;之间？为什么最好把 JS 的&lt;script&gt;标签恰好放在&lt;/body&gt;之前，有例外情况吗？"></a>3.为什么最好把 CSS 的<code>&lt;link&gt;</code>标签放在<code>&lt;head&gt;&lt;/head&gt;</code>之间？为什么最好把 JS 的<code>&lt;script&gt;</code>标签恰好放在<code>&lt;/body&gt;</code>之前，有例外情况吗？</h4><p>  把<code>&lt;link&gt;</code>放在<code>&lt;head&gt;</code>中  </p>
<p>把<code>&lt;link&gt;</code>标签放在<code>&lt;head&gt;&lt;/head&gt;</code>之间是规范要求的内容。此外，这种做法可以让页面逐步呈现，提高了用户体验。将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）不能逐步呈现页面。一些浏览器会阻止渲染，以避免在页面样式发生变化时，重新绘制页面中的元素。这种做法可以防止呈现给用户空白的页面或没有样式的内容。</p>
<p>  把<code>&lt;script&gt;</code>标签恰好放在<code>&lt;/body&gt;</code>之前  </p>
<p>脚本在下载和执行期间会阻止 HTML 解析。把<code>&lt;script&gt;</code>标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户。</p>
<p>例外情况是当你的脚本里包含<code>document.write()</code>时。但是现在，<code>document.write()</code>不推荐使用。同时，将<code>&lt;script&gt;</code>标签放在底部，意味着浏览器不能开始下载脚本，直到整个文档（document）被解析。也许，对此比较好的做法是，<code>&lt;script&gt;</code>使用<code>defer</code>属性，放在<code>&lt;head&gt;</code>中。</p>
<h4 id="4-什么是渐进式渲染（progressive-rendering）？"><a href="#4-什么是渐进式渲染（progressive-rendering）？" class="headerlink" title="4.什么是渐进式渲染（progressive rendering）？"></a>4.什么是渐进式渲染（progressive rendering）？</h4><p>渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术。</p>
<p>在以前互联网带宽较小的时期，这种技术更为普遍。如今，移动终端的盛行，而移动网络往往不稳定，渐进式渲染在现代前端开发中仍然有用武之地。</p>
<p>一些举例：</p>
<ul>
<li>图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript 将加载并显示图像。</li>
<li>确定显示内容的优先级（分层次渲染）——为了尽快将页面呈现给用户，页面只包含基本的最少量的 CSS、脚本和内容，然后可以使用延迟加载脚本或监听<code>DOMContentLoaded</code>/<code>load</code>事件加载其他资源和内容。</li>
<li>异步加载 HTML 片段——当页面通过后台渲染时，把 HTML 拆分，通过异步请求，分块发送给浏览器。更多相关细节可以在<a href="http://www.ebaytechblog.com/2014/12/08/async-fragments-rediscovering-progressive-html-rendering-with-marko/" target="_blank" rel="noopener">这里</a>找到。</li>
</ul>
<h4 id="5-viewport"><a href="#5-viewport" class="headerlink" title="5.viewport"></a>5.viewport</h4><p>Viewport ：字面意思为视图窗口，在移动web开发中使用。表示将设备浏览器宽度虚拟成一个特定的值（或计算得出），这样利于移动web站点跨设备显示效果基本一致。移动版的 Safari 浏览器最新引进了 viewport 这个 meta tag，让网页开发者来控制 viewport 的大小和缩放，其他手机浏览器也基本支持。</p>
<p>在移动端浏览器当中，存在着两种视口，一种是可见视口（也就是我们说的设备大小），另一种是视窗视口（网页的宽度是多少）。<br>举个例子：如果我们的屏幕是320像素   480像素的大小（iPhone4），假设在浏览器中，320像素的屏幕宽度能够展示980像素宽度的内容。那么320像素的宽度就是可见视口的宽度，而能够显示的980像素的宽度就是视窗视口的宽度。</p>
<p>为了显示更多的内容，大多数的浏览器会把自己的视窗视口扩大，简易的理解，就是让原本320像素的屏幕宽度能够容下980像素甚至更宽的内容（将网页等比例缩小）。</p>
<h4 id="6-Reflow和Repaint"><a href="#6-Reflow和Repaint" class="headerlink" title="6.Reflow和Repaint"></a>6.Reflow和Repaint</h4><p>Reflow：当涉及到DOM节点的布局属性发生变化时，就会重新计算该属性，浏览器会重新描绘相应的元素，此过程叫Reflow（回流或重排）。</p>
<p>Repaint：当影响DOM元素可见性的属性发生变化 (如 color) 时, 浏览器会重新描绘相应的元素, 此过程称为Repaint（重绘）。因此重排必然会引起重绘。</p>
<h4 id="7-引起Repaint和Reflow的一些操作"><a href="#7-引起Repaint和Reflow的一些操作" class="headerlink" title="7.引起Repaint和Reflow的一些操作"></a>7.引起Repaint和Reflow的一些操作</h4><ul>
<li>调整窗口大小</li>
<li>字体大小</li>
<li>样式表变动</li>
<li>元素内容变化，尤其是输入控件</li>
<li>CSS伪类激活，在用户交互过程中发生</li>
<li>DOM操作，DOM元素增删、修改</li>
<li>width, clientWidth, scrollTop等布局宽高的计算</li>
</ul>
<p>​    Repaint和Reflow是不可避免的，只能说对性能的影响减到最小，给出下面几条建议：</p>
<ul>
<li>避免逐条更改样式。建议集中修改样式，例如操作className。</li>
<li>避免频繁操作DOM。创建一个documentFragment或div，在它上面应用所有DOM操作，最后添加到文档里。设置display:none的元素上操作，最后显示出来。</li>
<li>避免频繁读取元素几何属性（例如scrollTop）。绝对定位具有复杂动画的元素。</li>
<li>绝对定位使它脱离文档流，避免引起父元素及后续元素大量的回流</li>
</ul>
<h4 id="8-img中的alt和元素的title属性作用"><a href="#8-img中的alt和元素的title属性作用" class="headerlink" title="8.img中的alt和元素的title属性作用"></a>8.img中的alt和元素的title属性作用</h4><ul>
<li>img的alt属性<br><br>如果无法显示图像，浏览器将显示alt指定的内容</li>
<li>元素title属性<br><br>在鼠标移到元素上时显示title的内容</li>
</ul>
<h4 id="9-href和src区别"><a href="#9-href和src区别" class="headerlink" title="9.href和src区别"></a>9.href和src区别</h4><ul>
<li>href <br><br>href标识超文本引用，用在link和a等元素上，href是引用和页面关联，是在当前元素和引用资源之间建立联系<br><br>若在文档中添加href ，浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。</li>
<li>src <br><br>src表示引用资源，替换当前元素，用在img，script，iframe上，src是页面内容不可缺少的一部分。<br><br>当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。</li>
</ul>
<p><a href="https://blog.csdn.net/lhjuejiang/article/details/80795081" target="_blank" rel="noopener">https://blog.csdn.net/lhjuejiang/article/details/80795081</a></p>
<p><a href="#HTML"></a></p>
<h4 id="10-浏览器的渲染过程"><a href="#10-浏览器的渲染过程" class="headerlink" title="10.浏览器的渲染过程"></a>10.浏览器的渲染过程</h4><ol>
<li>解析HTML生成DOM树。</li>
<li>解析CSS生成CSSOM规则树。</li>
<li>将DOM树与CSSOM规则树合并在一起生成渲染树。</li>
<li>遍历渲染树开始布局，计算每个节点的位置大小信息。</li>
<li>将渲染树每个节点绘制到屏幕。</li>
</ol>
<p><a href="https://baijiahao.baidu.com/s?id=1593097105869520145&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1593097105869520145&amp;wfr=spider&amp;for=pc</a></p>
<h4 id="11-处理兼容问题的思路"><a href="#11-处理兼容问题的思路" class="headerlink" title="11.处理兼容问题的思路"></a>11.处理兼容问题的思路</h4><ul>
<li><p>根据兼容需求选择技术框架/库(jquery)</p>
</li>
<li><p>根据兼容需求选择兼容工具(html5shiv.js、respond.js、css reset、normalize.css、Modernizr)</p>
</li>
<li><p>条件注释、CSS Hack、js 能力检测做一些修补</p>
</li>
<li><p>渐进增强(progressive enhancement): 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验</p>
</li>
<li><p>优雅降级 (graceful degradation): 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>
</li>
</ul>
<p><a href="https://github.com/jirengu/frontend-interview/issues/35" target="_blank" rel="noopener">https://github.com/jirengu/frontend-interview/issues/35</a></p>
<p><a href="#HTML">回到顶部</a></p>
<h4 id="12-doctype有什么用"><a href="#12-doctype有什么用" class="headerlink" title="12.doctype有什么用"></a>12.doctype有什么用</h4><p>doctype是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器要使用什么样的文档类型定义（DTD）来解析文档。</p>
<!DOCTYPE><p>声明是用来指示web浏览器关于页面使用哪个HTML版本进行编写的指令。</p>
<!DOCTYPE><p>声明必须是HTML文档的第一行，位于html标签之前。</p>
<p>浏览器本身分为两种模式，一种是标准模式，一种是怪异模式，浏览器通过doctype来区分这两种模式，doctype在html中的作用就是触发浏览器的标准模式，如果html中省略了doctype，浏览器就会进入到Quirks模式的怪异状态，在这种模式下，有些样式会和标准模式存在差异，而html标准和dom标准值规定了标准模式下的行为，没有对怪异模式做出规定，因此不同浏览器在怪异模式下的处理也是不同的，所以一定要在html开头使用doctype。</p>
<h4 id="13-标准模式和怪异模式区别区别："><a href="#13-标准模式和怪异模式区别区别：" class="headerlink" title="13.标准模式和怪异模式区别区别："></a>13.标准模式和怪异模式区别区别：</h4><p>总体会有布局、样式解析和脚本执行三个方面的区别。<br>盒模型：在 W3C 标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在 Quirks 模式下，IE 的宽度和高度还包含了 padding 和 border。<br>设置行内元素的高宽：在 Standards 模式下，给等行内元素设置 wdith 和 height 都不会生效，而在 quirks 模式下，则会生效。<br>设置百分比的高度：在 standards 模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的用<br>margin:0 auto 设置水平居中：使用 margin:0 auto 在 standards 模式下可以使元素水平居中，但在 quirks 模式下却会失效。</p>
<h4 id="14-一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。"><a href="#14-一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。" class="headerlink" title="14.一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。"></a>14.一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。</h4><p>图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。<br>如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。<br>如果图片为 css 图片，可以使用 CSSsprite，SVGsprite，Iconfont、Base64 等技术。<br>如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。<br>如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。</p>
<h4 id="15-严格模式与混杂模式的区别？"><a href="#15-严格模式与混杂模式的区别？" class="headerlink" title="15.严格模式与混杂模式的区别？"></a>15.严格模式与混杂模式的区别？</h4><p>严格模式下：页面排版及 JS 解析是以该浏览器支持的最高标准来执行<br>混杂模式：不严格按照标准执行，主要用来兼容旧的浏览器，向后兼容</p>
<h4 id="16-iframe有那些缺点？"><a href="#16-iframe有那些缺点？" class="headerlink" title="16.iframe有那些缺点？"></a>16.iframe有那些缺点？</h4><p> iframe会阻塞主页面的Onload事件；</p>
<p> 搜索引擎的检索程序无法解读这种页面，不利于SEO;</p>
<p> iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</p>
<p>使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript。动态给iframe添加src属性值，这样可以绕开以上两个问题。</p>
<h4 id="17-HTML与XHTML-二者有什么区别，你觉得应该使用哪一个并说出理由。"><a href="#17-HTML与XHTML-二者有什么区别，你觉得应该使用哪一个并说出理由。" class="headerlink" title="17.HTML与XHTML   二者有什么区别，你觉得应该使用哪一个并说出理由。"></a>17.HTML与XHTML   二者有什么区别，你觉得应该使用哪一个并说出理由。</h4><p>1.XHTML 元素必须被正确地嵌套。</p>
<p>错误：</p><p><span>thisis example.</span></p><p></p>
<p>正确：</p><p><span>thisis example.</span></p><p></p>
<p>2.XHTML 元素必须被关闭。</p>
<p>错误：</p><p>this isexample.</p>
<p>正确：</p><p>this isexample.</p><p></p>
<p>3.标签名必须用小写字母。</p>
<p>错误：</p><p>this isexample.</p><p></p>
<p>正确：</p><p>this isexample.</p><p></p>
<p>3.1空标签也必须被关闭</p>
<p>错误：<br></p>
<p>正确：<br></p>
<p>4.XHTML 文档必须拥有根元素。</p>
<p>所有的 XHTML 元素必须被嵌套于 <html> 根元素中。</html></p>
<h4 id="18-常见的浏览器内核有哪些？"><a href="#18-常见的浏览器内核有哪些？" class="headerlink" title="18.常见的浏览器内核有哪些？"></a>18.常见的浏览器内核有哪些？</h4><p>Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]</p>
<p>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等</p>
<p>Presto内核：Opera7及以上。     [Opera内核原为：Presto，现为：Blink;]</p>
<p>Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]</p>
<h4 id="19-HTML5的form如何关闭自动完成功能？"><a href="#19-HTML5的form如何关闭自动完成功能？" class="headerlink" title="19.HTML5的form如何关闭自动完成功能？"></a>19.HTML5的form如何关闭自动完成功能？</h4><p>给不想要提示的 form 或某个 input 设置为autocomplete=off。</p>
<h4 id="20-实现不使用-border-画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"><a href="#20-实现不使用-border-画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。" class="headerlink" title="20.  实现不使用     border   画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"></a>20.  实现不使用     border   画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</h4><div style="height:1px;overflow:hidden;background:red"></div>

<h4 id="21-title与h1的区别、b与strong的区别、i与em的区别？"><a href="#21-title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="21.title与h1的区别、b与strong的区别、i与em的区别？"></a>21.title与h1的区别、b与strong的区别、i与em的区别？</h4><p>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；</p>
<p>strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<strong>会重读，而<b>是展示强调内容。</b></strong></p>
<p>i内容展示为斜体，em表示强调的文本；</p>
<p>Physical Style Elements – 自然样式标签</p>
<p>b, i, u, s, pre</p>
<p>Semantic Style Elements – 语义样式标签</p>
<p>strong, em, ins, del, code</p>
<p>应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。</p>
<h4 id="22-请描述下-SEO-中的-TDK-？"><a href="#22-请描述下-SEO-中的-TDK-？" class="headerlink" title="22.请描述下    SEO    中的    TDK    ？"></a>22.请描述下    SEO    中的    TDK    ？</h4><p>在SEO中，所谓的TDK其实就是title、description、keywords这三个标签，这三个标签在网站的优化过程中</p>
<p>title标题标签，description描述标签，keywords关键词标签</p>
<h4 id="23-简单书写-HTML-代码：请写出一个-html-网站代码，内容为一个图片，链接到-“http-www-baidu-com”-，图片路径为-“-img-logo-png”-为图片设置替换文本-”webfoss”-新网页在新窗口打开；"><a href="#23-简单书写-HTML-代码：请写出一个-html-网站代码，内容为一个图片，链接到-“http-www-baidu-com”-，图片路径为-“-img-logo-png”-为图片设置替换文本-”webfoss”-新网页在新窗口打开；" class="headerlink" title="23. 简单书写    HTML    代码：请写出一个    html    网站代码，内容为一个图片，链接到    “http://www.baidu.com”    ，图片路径为    “./img/logo.png”,    为图片设置替换文本    ”webfoss”,    新网页在新窗口打开；"></a>23. 简单书写    HTML    代码：请写出一个    html    网站代码，内容为一个图片，链接到    “<a href="http://www.baidu.com”" target="_blank" rel="noopener">http://www.baidu.com”</a>    ，图片路径为    “./img/logo.png”,    为图片设置替换文本    ”webfoss”,    新网页在新窗口打开；</h4><p>答： <a href="”http://www.baidu.com”" alt="”webfoss”" target="”_blank”"><img src="”./img/logo.png”"></a></p>
<h4 id="24-标签上-title-与-alt-属性的区别是什么？"><a href="#24-标签上-title-与-alt-属性的区别是什么？" class="headerlink" title="24. 标签上    title    与    alt    属性的区别是什么？"></a>24. 标签上    title    与    alt    属性的区别是什么？</h4><p>alt是给搜索引擎识别，在图像无法显示时的替代文本；title是关于元素的注释信息，主要是给用户解读。当鼠标放到文字或是图片上时有title文字显示。（因为IE不标准）在IE浏览器中alt起到了title的作用，变成文字提示。在定义img对象时，将alt和title属性写全，可以保证在各种浏览器中都能正常使用。 </p>
<h4 id="25-前端页面有哪三层构成，分别是什么？作用是什么？"><a href="#25-前端页面有哪三层构成，分别是什么？作用是什么？" class="headerlink" title="25. 前端页面有哪三层构成，分别是什么？作用是什么？"></a>25. 前端页面有哪三层构成，分别是什么？作用是什么？</h4><p>分成：结构层、表示层、行为层。</p>
<p>结构层（structural layer）</p>
<p>由 HTML 或 XHTML之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。例如，P标签表达了这样一种语义：“这是一个文本段。”</p>
<p>表示层（presentationlayer）</p>
<p>由 CSS 负责创建。 CSS对“如何显示有关内容”的问题做出了回答。</p>
<p>行为层（behaviorlayer）</p>
<p>负责回答“内容应该如何对事件做出反应”这一问题。这是 Javascript 语言和 DOM主宰的领域。</p>
<h4 id="26-每个-HTML-文件头里都有个很重要的东西，-Doctype-，知道这是干什么的么？"><a href="#26-每个-HTML-文件头里都有个很重要的东西，-Doctype-，知道这是干什么的么？" class="headerlink" title="26.每个    HTML    文件头里都有个很重要的东西，    Doctype    ，知道这是干什么的么？"></a>26.每个    HTML    文件头里都有个很重要的东西，    Doctype    ，知道这是干什么的么？</h4><!DOCTYPE><p> 声明位于文档中的最前面的位置，处于 <html> 标签之前。</html></p>
<p>作用：</p>
<p>1.告知浏览器文档使用哪种 HTML 或 XHTML 规范。</p>
<p>2.告诉浏览器按照何种规范解析页（如果你的页面没有DOCTYPE的声明，那么compatMode默认就是BackCompat,浏览器按照自己的方式解析渲染页面）</p>
<h4 id="27-DIV-CSS-布局较-table-有什么优势？"><a href="#27-DIV-CSS-布局较-table-有什么优势？" class="headerlink" title="27.DIV+CSS    布局较    table    有什么优势？"></a>27.DIV+CSS    布局较    table    有什么优势？</h4><p>1、速率更快，页面体积变小，浏览速度变快，这就使得对于某些控制主机流量的网站来说是最大的优势了；</p>
<p>2、更好地被搜索引擎收录，大部分html页面的样式写入了CSS文件中，便于被搜索引擎采集收录；</p>
<p>3、对浏览者和浏览器更具优势，由于CSS富含丰富的样式，使页面更加灵活性，它可以根据不同的浏览器，而达到显示效果的统一和不变形；</p>
<p>4、修改更有效率，由于使用了DIV+CSS制作方法，在修改页面的时候更加容易省时，提高工作效率；</p>
<h4 id="28-为什么用多个域名存储网站资源更有效？"><a href="#28-为什么用多个域名存储网站资源更有效？" class="headerlink" title="28.为什么用多个域名存储网站资源更有效？"></a>28.为什么用多个域名存储网站资源更有效？</h4><p>1、CDN缓存更方便</p>
<p>2、突破浏览器并发限制</p>
<p>3、节约cookie带宽</p>
<p>4、节约主域名的连接数，优化页面响应速度</p>
<p>5、防止不必要的安全问题</p>
<h4 id="29-简要说明一下做好-SEO-需要考虑哪些方面？"><a href="#29-简要说明一下做好-SEO-需要考虑哪些方面？" class="headerlink" title="29.简要说明一下做好    SEO    需要考虑哪些方面？"></a>29.简要说明一下做好    SEO    需要考虑哪些方面？</h4><p>1.TDK</p>
<p>2.图片+alt</p>
<p>3.友情链接</p>
<p>4.站点地图</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/06/01/嗯哼/">
                嗯哼
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-06-01</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</span><br></pre></td></tr></table></figure>


        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/06/01/boke/">
                Hello World
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-06-01</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">之前的数据存储方案：</span><br><span class="line">第一步：数据都是放在内存中的</span><br><span class="line">        占用内存资源、数据存取非常快、当程序关闭的时候数据丢失</span><br><span class="line"></span><br><span class="line">第二步：数据存文件中</span><br><span class="line">        Localstorage   db.json  </span><br><span class="line">        数据会持久保存、涉及文件的频繁读(读所有数据)写(覆盖)、IO效率没那么高</span><br><span class="line"></span><br><span class="line">第三步：数据保存在数据库里面</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数据库软件：是存放和管理数据的软件，用来按照特定的结构去组织和管理我们的数据，有了数据库我们就可以更加方便、便捷的操作（C / R / U / D）我们需要保存的数据</span><br></pre></td></tr></table></figure>

<h3 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">关系型数据库：oracle   mysql   db2   sqlserver</span><br><span class="line"> 数据库        文件</span><br><span class="line"> 表           表的字段信息+表的数据信息</span><br><span class="line"> 表的数据      表的数据信息部分</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">非关系型数据库 ：mongodb   redis  hbase</span><br><span class="line">键值类数据库 ： Redis     例：name:zhangsan   age:18   gender:男</span><br><span class="line">列存储数据库 : HBase</span><br><span class="line">文档类数据库 : MongoDB   里面可以直接存储文档</span><br><span class="line">图形数据库 : Graph</span><br><span class="line"></span><br><span class="line">MongoDB是最像关系型数据库的非关系型数据库</span><br><span class="line"></span><br><span class="line">MongoDB的组成：</span><br><span class="line">数据库     数据库</span><br><span class="line">表         集合 Collection</span><br><span class="line">表的数据   文档对象  Documen</span><br><span class="line"></span><br><span class="line">MongoDB特点：</span><br><span class="line">1.面向集合存储</span><br><span class="line">2.无模式结构存储</span><br><span class="line">3.支持索引(索引进行快速查询数据的一种方式)</span><br><span class="line">4.支持很多查询的方法</span><br><span class="line">5.强大的聚合工具</span><br><span class="line">6.支持数据的备份和恢复、复制</span><br><span class="line">7.支持集群</span><br><span class="line">8.支持多种语言的数据操作</span><br><span class="line">9.高性能、可扩展、易部署、易使用，存储数据非常方便</span><br></pre></td></tr></table></figure>

<h3 id="安装mongodb"><a href="#安装mongodb" class="headerlink" title="安装mongodb"></a>安装mongodb</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.不要安装界面化的软件</span><br><span class="line">2.装完之后通过Mongod --version来查看mongodb的版本号</span><br><span class="line">3.装完之后我们需要制定mongdb使用的数据库的目录(默认情况下mongodb使用的目录是c:/data/db目录  如果c盘没有这个目录，则手动创建)</span><br><span class="line">修改mongodb默认的存储目录：mongod --datapath=数据存储目录</span><br><span class="line">4.使用mongod命令来开启mongodb的服务了  mongodb使用的端口号是27017</span><br><span class="line">终止mongodb的服务器用:  ctrl+c</span><br></pre></td></tr></table></figure>

<h3 id="连接mongodb服务器"><a href="#连接mongodb服务器" class="headerlink" title="连接mongodb服务器"></a>连接mongodb服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">打开命令行，输入mongo命令来连接数据库</span><br><span class="line"></span><br><span class="line">注意点：命令行中如果输入mongod命令式来启动mongodb服务器</span><br><span class="line">如果输入mongo命令来连接数据库服务器(客户端)</span><br></pre></td></tr></table></figure>

<h3 id="mongodb的常用命令"><a href="#mongodb的常用命令" class="headerlink" title="mongodb的常用命令"></a>mongodb的常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">常用命令：</span><br><span class="line">show dbs      显示所有数据库</span><br><span class="line">use igeek    使用igeek这个数据库(如果数据库不存在会自动创建)</span><br><span class="line">db.student.insert(&#123;_id:1,name:”test”&#125;)   //向当前数据库下插入一条数据并指定数据的唯一标识符id为1</span><br><span class="line">db.student.insert(&#123;&quot;name&quot;:&quot;tom&quot;&#125;)   //向当前数据库下插入一条数据并不指定数据的唯一标识符id，会随机生成一个id</span><br><span class="line">show collections   显示当前数据库下面的所有集合</span><br><span class="line">db.student.find()    查看当前数据库下面student集合中的所有数据</span><br><span class="line">db.dropDatabase()    删除当前数据库</span><br><span class="line">db.createCollection(&quot;animal&quot;)   在当前数据库下面创建一个collection叫animal</span><br><span class="line">db.animal.drop()   删除当前数据库下的animal这个collection集合</span><br><span class="line"></span><br><span class="line">db.igeekhome.cat.insert(&#123;name:&quot;hello kitty&quot;&#125;)  //向当前数据库下的igeekhome.cat 表中插入一条数据</span><br><span class="line">db.cat.insert(&#123;name:&quot;加菲猫&quot;&#125;) //向当前数据库下的cat 表中插入一条数据</span><br><span class="line">db.cat.find();</span><br><span class="line">db.cat.remove(&#123;name: &quot;加菲猫&quot;&#125;)   //移除当前数据库下cat表的中name是加菲猫的数据</span><br><span class="line"></span><br><span class="line">//修改name为pp的数据，将name为pp的数据改成name为mm</span><br><span class="line">//upsert:true 如果要更新的文档不存在会插入一条新的记录并且修改</span><br><span class="line">// multi:true 会更新数据库的cat表中的所有name为pp的数据</span><br><span class="line">db.cat.update(&#123;name:&quot;pp&quot;&#125;,&#123; $set: &#123; name:&quot;mm&quot; &#125; &#125;,&#123; upsert:true,multi:true &#125;)</span><br><span class="line"></span><br><span class="line">// save()方法有两个作用</span><br><span class="line">//如果save()传了id参数，并且id值在原数据库中存在，则会修改数据库中的数据。如果不存在，则会新建一条数据</span><br><span class="line">db.cat.save(&#123;_id:ObjectId(&quot;5cf336d51ff4541f8c5bb63e&quot;),name:&quot;gg&quot;,hobbies:[&quot;足球&quot;,&quot;篮球&quot;]&#125;)</span><br><span class="line"></span><br><span class="line">//此时save()方法没有传入id参数，就会在数据库的表中新建一条数据</span><br><span class="line">db.cat.save(&#123;name:&quot;ll&quot;,hobbies:[&quot;足球&quot;,&quot;篮球&quot;]&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="mongodb查询"><a href="#mongodb查询" class="headerlink" title="mongodb查询"></a>mongodb查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">mongoimport -d 数据库名字 -c 集合的名字 文件名</span><br><span class="line"></span><br><span class="line">db.student.find()     查询当前数据库下的student表的所有内容</span><br><span class="line"></span><br><span class="line">//查询姓名是李灵黛的student</span><br><span class="line">db.student.find(&#123;name:&quot;李灵黛&quot;&#125;)</span><br><span class="line"></span><br><span class="line">//查询指定id的学生(id是唯一的)</span><br><span class="line">db.student.find(&#123;_id:ObjectId(&quot;5cf33cf6a7ba70e3fa58a8e0&quot;)&#125;)</span><br><span class="line"></span><br><span class="line">//查询名字是李念儿的并且年龄是19的人</span><br><span class="line">db.student.find(&#123;name:&quot;李念儿&quot;,age:19&#125;)</span><br><span class="line"></span><br><span class="line">//查询名字是李念儿 或者 年龄是19的</span><br><span class="line">db.student.find(&#123;$or:[&#123;name:&quot;李念儿&quot;&#125;,&#123;age:19&#125;]&#125;)</span><br><span class="line"></span><br><span class="line">//查询年龄大于30的</span><br><span class="line">db.student.find(&#123;age:&#123;$gt:30&#125;&#125;)</span><br><span class="line">//查询年龄大于等于30的</span><br><span class="line">db.student.find(&#123;age:&#123;$gte:30&#125;&#125;)</span><br><span class="line">//查询年龄小于30的</span><br><span class="line">db.student.find(&#123;age:&#123;$lt:30&#125;&#125;)</span><br><span class="line">//查询年龄小于等于30的</span><br><span class="line">db.student.find(&#123;age:&#123;$lte:30&#125;&#125;)</span><br><span class="line">//查询年龄等于30的</span><br><span class="line">db.student.find(&#123;age:30&#125;)</span><br><span class="line">//查询年龄不等于13的</span><br><span class="line">db.student.find(&#123;age:&#123;$ne:13&#125;&#125;)</span><br><span class="line"></span><br><span class="line">//跳过前面1条数据，获取两条数据(可以来做分页查询)</span><br><span class="line">db.student.find().limit(2).skip(1)</span><br><span class="line"></span><br><span class="line">//按照年龄排序  -1降序  1升序</span><br><span class="line">db.student.find().sort(&#123;age:-1&#125;)</span><br><span class="line"></span><br><span class="line">//求所有年龄的和</span><br><span class="line">//mongodb中聚合查询 $sum  $avg  $min  $max  $first  $last</span><br><span class="line">//在mongodb中做聚合查询用aggregate()函数</span><br><span class="line">//聚合查询：可以对一组数据进行查询  得到一个结果</span><br><span class="line">db.student.aggregate( [</span><br><span class="line">   &#123;</span><br><span class="line">     $group: &#123;</span><br><span class="line">        _id: null,</span><br><span class="line">        total: &#123; $sum: &quot;$age&quot; &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">] )</span><br><span class="line"></span><br><span class="line">//求所有年龄的平均数</span><br><span class="line">db.student.aggregate( [</span><br><span class="line">   &#123;</span><br><span class="line">     $group: &#123;</span><br><span class="line">        _id: null,</span><br><span class="line">        total: &#123; $avg: &quot;$age&quot; &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">] )</span><br><span class="line"></span><br><span class="line">//求第一个年龄</span><br><span class="line">db.student.aggregate( [</span><br><span class="line">   &#123;</span><br><span class="line">     $group: &#123;</span><br><span class="line">        _id: null,</span><br><span class="line">        total: &#123; $first: &quot;$age&quot; &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">] )</span><br></pre></td></tr></table></figure>

<h1 id="Node中操作mongodb"><a href="#Node中操作mongodb" class="headerlink" title="Node中操作mongodb"></a>Node中操作mongodb</h1><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">使用的技术是 ：mongoose</span><br><span class="line">//1.安装mongoose  npm install mongoose</span><br><span class="line">//2.引入到server.js中</span><br><span class="line"><span class="built_in">let</span> mongoose = require(<span class="string">'mongoose'</span>);</span><br><span class="line">//3.去连接指定的数据库</span><br><span class="line">mongoose.connect(<span class="string">'mongodb://localhost:27017/igeek'</span>, &#123;useNewUrlParser: <span class="literal">true</span>&#125;);</span><br><span class="line">//4.拿到连接对象</span><br><span class="line">var db = mongoose.connection;</span><br><span class="line">//5.连接对象的回调  </span><br><span class="line">//db.on(<span class="string">'error'</span>,连接出错的执行代码)</span><br><span class="line">db.on(<span class="string">'error'</span>, console.error.bind(console, <span class="string">'connection error:'</span>));</span><br><span class="line">//db.once(<span class="string">'open'</span>,<span class="function"><span class="title">function</span></span>()&#123;连接成功的回调&#125;)</span><br><span class="line">db.once(<span class="string">'open'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">   console.log(<span class="string">"已经连接数据库"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//6.创建一个Scheme.这个Scheme是和数据库的集合对应的</span><br><span class="line">// ORM  object relational model  对象关系映射模型</span><br><span class="line">var studentSchema = new mongoose.Schema(&#123;</span><br><span class="line">   name: String,</span><br><span class="line">   age: Number,</span><br><span class="line">   sex: String,</span><br><span class="line">   province: String</span><br><span class="line">&#125;);</span><br><span class="line">//注意点：这边的Student对应数据库中的students表 (注意这个s)</span><br><span class="line">//7.创建一个Model</span><br><span class="line">var Student = mongoose.model(<span class="string">'Student'</span>, studentSchema);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//8.调用Model的方法查询数据库</span><br><span class="line">//Model.find(<span class="keyword">function</span>(err,arr)&#123;&#125;)   //err表示查询过程中的错误，arr表示查询的结果</span><br><span class="line">.finStudentd(<span class="keyword">function</span>(err, arr)&#123;</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		console.log(err);</span><br><span class="line">		<span class="built_in">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		console.log(arr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="schema的类型"><a href="#schema的类型" class="headerlink" title="schema的类型"></a>schema的类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">String</span><br><span class="line">Number</span><br><span class="line">Date</span><br><span class="line">Buffer</span><br><span class="line">Boolean</span><br><span class="line">Mixed (混合类型，什么都能放)</span><br><span class="line">ObjectId(id类型，表示唯一的数据)</span><br><span class="line">Array</span><br><span class="line">Map</span><br><span class="line"></span><br><span class="line">//schema改掉之后对之前的数据没有影响</span><br><span class="line">var studenSchema = new mongoose.Schema(&#123;</span><br><span class="line">	//_id的类型是ObjectId类型</span><br><span class="line">	_id: mongoose.Schema.Types.ObjectId,</span><br><span class="line">	//name是String类型的</span><br><span class="line">	name: &#123;</span><br><span class="line">		type: String,</span><br><span class="line">		required: true,</span><br><span class="line">        //字符串的最小长度2</span><br><span class="line">    	minlength: 2,</span><br><span class="line">        //字符串的最大长度是5</span><br><span class="line">    	maxlength: 5</span><br><span class="line">	&#125;,</span><br><span class="line">	email: &#123;</span><br><span class="line">		type: String,</span><br><span class="line">        //正则的校验规则</span><br><span class="line">		match: /^\w&#123;2,&#125;@\w&#123;2,&#125;\.com$/</span><br><span class="line">	&#125;,</span><br><span class="line">	//age是Number类型的</span><br><span class="line">	age: &#123;</span><br><span class="line">		type: Number,</span><br><span class="line">        //age没有写的时候默认是100</span><br><span class="line">		default: 100,</span><br><span class="line">        //age最小是0 最大是130</span><br><span class="line">		min: 0,</span><br><span class="line">		max: 130</span><br><span class="line">	&#125;,</span><br><span class="line">	//birthday是时间的类型的</span><br><span class="line">	birthday: Date, </span><br><span class="line">	//adult是Boolean类型的</span><br><span class="line">	adult: Boolean,</span><br><span class="line">	//message是混合类型的数组(数组里面什么都可以放)</span><br><span class="line">	message: [mongoose.Schema.Types.Mixed],</span><br><span class="line">	//hobbies是数组类型的(数组里面只能放字符串)</span><br><span class="line">	hobbies: [String],</span><br><span class="line">	//scores是数组类型的(数组里面放指定的对象)</span><br><span class="line">	scores: [&#123;subject : String , score : Number&#125;],</span><br><span class="line">	//gender是Number类型，但是他的值只能在0和1之间选择，默认值是0</span><br><span class="line">	gender: &#123;</span><br><span class="line">		type: Number,</span><br><span class="line">        enum: [0, 1],</span><br><span class="line">        default: 0</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意点：如果要为某个字段添加索引，我们可以通过如下方式来添加索引：</span><br><span class="line">db.students.ensureIndex(</span><br><span class="line">   &#123; &quot;name&quot; : 1 &#125;,</span><br><span class="line">   &#123; unique: true &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="mongoose支持的方法"><a href="#mongoose支持的方法" class="headerlink" title="mongoose支持的方法"></a>mongoose支持的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">新增数据：</span><br><span class="line">//Model对象.save().then(function(data)&#123;</span><br><span class="line">   //Data是保存成功后的那个对象;</span><br><span class="line">//&#125;)</span><br><span class="line"></span><br><span class="line">xiaobai.save().then(function(data)&#123;</span><br><span class="line">	console.log(data,&quot;保存完毕&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">删除数据：</span><br><span class="line">//Model.remove(&#123;&#125;).then(function(msg)&#123;&#125;)</span><br><span class="line"></span><br><span class="line">Student.remove(&#123;name:&quot;小百是&quot;&#125;)</span><br><span class="line">.then(function(msg)&#123;</span><br><span class="line">	//删除数据的一些信息</span><br><span class="line">	console.log(msg)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">修改数据：</span><br><span class="line">Student.update(&#123;name:&quot;小黄是&quot;&#125;,&#123;$set:&#123;name:&quot;xiaohuang&quot;&#125;&#125;)</span><br><span class="line">.then(function(msg)&#123;</span><br><span class="line">	//修改成功的一些状态信息</span><br><span class="line">	console.log(msg);</span><br><span class="line">&#125;,function(err)&#123;</span><br><span class="line">	console.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">查询数据：</span><br><span class="line">//查询所有数据</span><br><span class="line">Student.find()</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">	console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//find()返回查询的数据的数组集合</span><br><span class="line">Student.find(&#123;name:&quot;小黑&quot;&#125;)</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">	console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//findOne()返回查询到的一个对象</span><br><span class="line">Student.findOne(&#123;name:&quot;小黑&quot;&#125;)</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">	console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//根据id查询指定数据</span><br><span class="line">Student.findById(&quot;5cf36fbd40612d2174b9ec13&quot;)</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">	console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//根据id查询，并更新该数据</span><br><span class="line">Student.findByIdAndUpdate(&quot;5cf36fbd40612d2174b9ec13&quot;,&#123;$set:&#123;name:&quot;tt&quot;&#125;&#125;)</span><br><span class="line">.then(function(msg)&#123;</span><br><span class="line">	console.log(msg);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//根据id查询并删除该数据</span><br><span class="line">Student.findByIdAndDelete(&quot;5cf36fbd40612d2174b9ec13&quot;)</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">	//删除的那个元素</span><br><span class="line">	console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//查询姓名是小百或者年龄是23的人</span><br><span class="line">Student.findOne(&#123;$or:[&#123;name:&quot;小白&quot;&#125;,&#123;age:23&#125;]&#125;)</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">	console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//跳过前面一条查询两条数据</span><br><span class="line">Student.find()</span><br><span class="line">.skip(1)</span><br><span class="line">.limit(2)</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">	console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//查询年龄大于等于1小于等于110的学生</span><br><span class="line">Student.find(&#123;age: &#123;$gte: 1, $lte: 110&#125;&#125;)</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">	console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//查询年龄大于等1并且小于等于110的学生 并且这个学生的名字是小白</span><br><span class="line">Student</span><br><span class="line">.where(&quot;age&quot;).gte(1).lte(110)</span><br><span class="line">.where(&quot;name&quot;,&quot;小白&quot;)</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">	console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">静态方法和动态方法：</span><br><span class="line">//静态方法 ： 可以直接给Model类新增方法</span><br><span class="line">//当前模型层的类来调用   Student.findByName()</span><br><span class="line">studenSchema.statics.findByName = function(name,callback)&#123;</span><br><span class="line">	this.find(&#123;&quot;name&quot; : name&#125;)</span><br><span class="line">	.then(function(data)&#123;</span><br><span class="line">		callback(data[0]);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//实例方法  需要模型层对象来调用</span><br><span class="line">// new Student().sayHello()</span><br><span class="line">studenSchema.methods.sayHello = function()&#123;</span><br><span class="line">	//这里的this指的是这个实例</span><br><span class="line">	console.log(&quot;当当当当！我是&quot; + this.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//关联查询    id  name  age  sex  部门名字</span><br><span class="line">employee.find()      //查找所有的员工</span><br><span class="line">.populate(&#123; path: &apos;dep&apos;, select: &#123; name: 1 &#125; &#125;)  //进行关联查询，用department表中的name字段来填充dep字段的内容</span><br><span class="line">.exec(function(err, obj) &#123;  //exec 执行查询</span><br><span class="line">     console.log(obj)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


        </div>
    

</div>
            
        </section>
    </div>
</div>






</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a href="https://github.com/klugjo">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2019/06/10/CSS/">Untitled</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/06/10/JavaSciprt/">Untitled</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/06/10/HTTP/">Untitled</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/06/10/HTML/">Untitled</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klugjo/hexo-theme-alpha-dust">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://twitter.com/?lang=en">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.facebook.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.instagram.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://dribbble.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://plus.google.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-google-plus"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.behance.net/">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://500px.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>